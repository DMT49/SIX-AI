
<script type="text/javascript">!function(o,c){var n=c.documentElement,t=" w-mod-";n.className+=t+"js",("ontouchstart"in o||o.DocumentTouch&&c instanceof DocumentTouch)&&(n.className+=t+"touch")}(window,document);</script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify/dist/purify.min.js"></script>
  <div class="chat-bot_styles w-embed">
  </div>
  <div class="page-wrapper is-app is-ami">
    <div class="main-wrapper">
      <div class="shell15_wrapper">
        <main class="shell15_main-wrapper">
          <div id="chat_conversation-wrapper" class="chat_conversation-wrapper"></div>
          <div class="chat_input-wrapper">
            <div id="w-node-_65169329-54c4-8195-cf7f-c09cde35a8e3-8f158f72" class="chat_input-file">
              <div class="icon-embed-small w-embed"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--ic" width="100%" height="100%" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24">
                  <path fill="currentColor" d="M16.5 6v11.5c0 2.21-1.79 4-4 4s-4-1.79-4-4V5a2.5 2.5 0 0 1 5 0v10.5c0 .55-.45 1-1 1s-1-.45-1-1V6H10v9.5a2.5 2.5 0 0 0 5 0V5c0-2.21-1.79-4-4-4S7 2.79 7 5v12.5c0 3.04 2.46 5.5 5.5 5.5s5.5-2.46 5.5-5.5V6z"></path>
                </svg></div>
            </div>
            <div id="chat-user-input-mic" class="chat_input-file w-node-d52fb02a-d5b0-6fa8-115b-d486e3e4b322-8f158f72">
              <div class="icon-embed-small w-embed"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--ic" width="100%" height="100%" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24">
                  <path fill="currentColor" d="M12 15c1.66 0 2.99-1.34 2.99-3L15 6c0-1.66-1.34-3-3-3S9 4.34 9 6v6c0 1.66 1.34 3 3 3m-1.2-9.1c0-.66.54-1.2 1.2-1.2s1.2.54 1.2 1.2l-.01 6.2c0 .66-.53 1.2-1.19 1.2s-1.2-.54-1.2-1.2zm6.5 6.1c0 3-2.54 5.1-5.3 5.1S6.7 15 6.7 12H5c0 3.41 2.72 6.23 6 6.72V22h2v-3.28c3.28-.48 6-3.3 6-6.72z"></path>
                </svg></div>
            </div>
            <div id="w-node-_819b1fcb-bef5-c69d-b33b-f104bd5e9695-8f158f72" class="chat_input-text">
              <div id="w-node-_256faa1f-1943-6b85-6f8e-bd7a8a4af011-8f158f72" class="code-embed-2 w-embed">
                <div class="form-input is-app">
                  <textarea id="chat-user-input" class="textarea-dynamic" rows="1" placeholder="Type your message here..."></textarea>
                </div>
              </div>
            </div>
            <div id="chat-user-submit" class="button is-app w-node-_4bf83d64-1477-4e83-8a98-23560ff07d2d-8f158f72 w-inline-block" draggable="false">
              <div class="chat_submit-input w-embed"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--heroicons" width="100%" height="100%" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24">
                  <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M6 12L3.269 3.125A59.8 59.8 0 0 1 21.486 12a59.8 59.8 0 0 1-18.217 8.875zm0 0h7.5"></path>
                </svg></div>
            </a>
          </div>
        </main>
      </div>
    </div>
  </div>

<!-- Existing HTML structure remains unchanged -->

<script>
  // Immediately execute the chatbot initialization code
  (function() {
    console.log("Chatbot initialized.");

    // 1) Get the container in which this HTML was injected
    const container = document.getElementById("ai-agent-container");
    
    // 2) Read data attributes (fallback to defaults if missing)
    const agentId = container?.getAttribute("data-agent-id") || "6a12b1cd-b7d5-4b00-80ee-d2829af810dc";
    const name    = container?.getAttribute("data-user-name") || "Guest";
    const email   = container?.getAttribute("data-user-email") || "noemail@domain.com";
    
    // Configuration for AI agent
    const region = "bcbe5a"; // Replace with your region
    const projectId = "c5bf489c1af9-4886-afba-073965a5ad71"; // Replace with your project ID
    const apiKey = "sk-MGJlOWM0NGEtMjgyNC00MTIwLTg5NGUtN2IwMzljMmNjNDgx"; // Replace with your API key
    
    // Use base64 encoding for the authorization token
    const authorizationToken = `Basic ${btoa(`${projectId}:${apiKey}`)}`;
    const baseUrl = `https://api-${region}.stack.tryrelevance.com/latest`;
    const headers = {
      Authorization: authorizationToken,
      "Content-Type": "application/json",
    };
    
    // DOM elements
    const textarea = document.getElementById("chat-user-input");
    const micButton = document.getElementById("chat-user-input-mic");
    const userSubmit = document.getElementById("chat-user-submit");
    const conversationWrapper = document.getElementById("chat_conversation-wrapper");
    const chatInputWrapper = document.querySelector(".chat_input-wrapper");

    const urlParams = new URLSearchParams(window.location.search);
    const conversationID = urlParams.get('conversationID');

    let airtableRecordId = null;


        // Function to fetch profile image from Airtable
    async function fetchAgentProfileImage(agentId) {
      try {
        const airtableBaseUrl = 'https://api.airtable.com/v0/app2N6x5jeRnIzSpL/Agents';
        const airtableHeaders = {
          Authorization: 'Bearer patTeuxUuzgG0ZU8Q.2eb9ff7f31afe3e06f3c128c5b5b832bcc4e4e85bd58a5007a8368f218d28b83',
          'Content-Type': 'application/json',
        };
    
        const response = await fetch(`${airtableBaseUrl}?filterByFormula={Agent-ID}="${agentId}"`, {
          method: 'GET',
          headers: airtableHeaders,
        });
    
        if (response.ok) {
          const data = await response.json();
          if (data.records && data.records.length > 0) {
            const profileImage = data.records[0].fields['Profile-Image'][0].url;
            console.log("Profile Image URL:", profileImage);
            return profileImage;
          } else {
            console.log("No record found for Agent-ID:", agentId);
            return null;
          }
        } else {
          console.error("Failed to fetch data from Airtable:", await response.text());
          return null;
        }
      } catch (error) {
        console.error("Error fetching profile image from Airtable:", error);
        return null;
      }
    }
    
    function updateChatBotAvatarStyle(profileImage) {
      if (profileImage) {
        const style = document.createElement('style');
        style.textContent = `
          .chat_bot-avatar {
            background-image: url("${profileImage}") !important;
            background-size: cover !important;
            background-position: center !important;
            background-repeat: no-repeat !important;
          }
        `;
        document.head.appendChild(style);
        console.log("Updated chat_bot-avatar style globally with !important.");
      } else {
        console.log("No profile image provided, skipping style update.");
      }
    }

    
    // Initialize the process
    (async function initializeChatBot() {
      const agentId = container?.getAttribute("data-agent-id") || "6a12b1cd-b7d5-4b00-80ee-d2829af810dc";
      const profileImage = await fetchAgentProfileImage(agentId);
      updateChatBotAvatarStyle(profileImage);
    })();


    // Function to fetch user profile image from Airtable using Email
    async function fetchUserProfileImageByEmail(email) {
      try {
        const airtableBaseUrl = 'https://api.airtable.com/v0/app2N6x5jeRnIzSpL/Users'; // Replace with your actual base
        const airtableHeaders = {
          Authorization: 'Bearer patTeuxUuzgG0ZU8Q.2eb9ff7f31afe3e06f3c128c5b5b832bcc4e4e85bd58a5007a8368f218d28b83',
          'Content-Type': 'application/json',
        };
    
        // Use the email to filter records
        const response = await fetch(`${airtableBaseUrl}?filterByFormula={Email}="${email}"`, {
          method: 'GET',
          headers: airtableHeaders,
        });
    
        if (response.ok) {
          const data = await response.json();
          if (data.records && data.records.length > 0) {
            const profileImage = data.records[0].fields['Profile-Image'][0].url;
            console.log("User Profile Image URL:", profileImage);
            return profileImage;
          } else {
            console.log("No record found for Email:", email);
            return null;
          }
        } else {
          console.error("Failed to fetch data from Airtable:", await response.text());
          return null;
        }
      } catch (error) {
        console.error("Error fetching user profile image from Airtable:", error);
        return null;
      }
    }
    
    // Function to update the global style for chat_user-avatar
    function updateChatUserAvatarStyle(profileImage) {
      if (profileImage) {
        const style = document.createElement('style');
        style.textContent = `
          .chat_user-avatar {
            background-image: url("${profileImage}") !important;
            background-size: cover !important;
            background-position: center !important;
            background-repeat: no-repeat !important;
          }
        `;
        document.head.appendChild(style);
        console.log("Updated chat_user-avatar style globally with !important.");
      } else {
        console.log("No user profile image provided, skipping style update.");
      }
    }
    
    // Initialize the process for user profile image
    (async function initializeUserAvatar() {
      const userProfileImage = await fetchUserProfileImageByEmail(email); // Use the email variable defined in the code
      updateChatUserAvatarStyle(userProfileImage);
    })();

    async function saveConversationToAirtable(metadata) {
      const conversationsTableUrl = 'https://api.airtable.com/v0/app2N6x5jeRnIzSpL/Conversations';
      const airtableHeaders = {
        Authorization: 'Bearer patTeuxUuzgG0ZU8Q.2eb9ff7f31afe3e06f3c128c5b5b832bcc4e4e85bd58a5007a8368f218d28b83',
        'Content-Type': 'application/json',
      };
    
      try {
        const response = await fetch(conversationsTableUrl, {
          method: 'POST',
          headers: airtableHeaders,
          body: JSON.stringify({
            fields: {
              'Client-Name': metadata.userName,
              'Agent-ID': metadata.agentID,
              'Conversation-ID': metadata.conversationID,
              'Time-Stamp': metadata.timeStamp,
              'User-ID': metadata.userId,
            },
          }),
        });
    
        if (response.ok) {
          const data = await response.json();
          console.log('Conversation metadata saved successfully:', data);
          return data; // Return the saved record
        } else {
          const errorText = await response.text();
          console.error('Failed to save conversation metadata:', errorText);
          return null;
        }
      } catch (error) {
        console.error('Error saving conversation metadata to Airtable:', error);
        return null;
      }
    }


    // Function to fetch and log conversation messages
    async function fetchConversationMessages(conversationID) {
      if (!conversationID) {
        console.log("No conversationID provided.");
        return;
      }
    
      try {
        const response = await fetch(`${baseUrl}/knowledge/list`, {
          method: "POST",
          headers: {
            Authorization: authorizationToken,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            knowledge_set: conversationID,
            page_size: 999, // Adjust as needed
            sort: [{ insert_date_: "desc" }], // Newest message first
          }),
        });
    
        if (!response.ok) {
          console.error("Error fetching conversation:", await response.text());
          return;
        }
    
        const data = await response.json();
        const messages = data.results || [];
    
        console.log("Fetched conversation messages:", messages);
        return messages;
      } catch (error) {
        console.error("Error accessing Relevance API:", error);
      }
    }
    

    // Function to render conversation messages in the chat UI
    function renderConversationMessages(messages) {
      if (!Array.isArray(messages) || messages.length === 0) {
        console.log("No messages to render.");
        return;
      }
    
      // Reverse the order to render messages in chronological order
      messages.reverse();
    
      // Skip the first user message if it exists
      const filteredMessages = messages.filter((message, index) => {
        const role = message?.data?.message?.role;
        // Exclude the very first user message
        return !(index === 0 && role === "user");
      });
    
      // Render the remaining messages
      filteredMessages.forEach((message) => {
        const role = message?.data?.message?.role;
        const content = message?.data?.message?.content;
    
        if (role && content) {
          const isUser = role === "user";
          createChatBlock(isUser, content);
        }
      });
    
      // Scroll to the bottom of the conversation
      conversationWrapper.scrollTop = conversationWrapper.scrollHeight;
    }


    
    if (conversationID) {
      console.log("Conversation ID found:", conversationID);
    
      // Fetch and render messages
      fetchConversationMessages(conversationID).then((messages) => {
        if (messages) {
          renderConversationMessages(messages);
          conversationId = conversationID; // Set global conversationId here
          console.log("Global conversationId set to:", conversationId);
        } else {
          console.error("Failed to fetch conversation messages.");
        }
    
        // Show the input wrapper after messages are loaded
        chatInputWrapper.style.display = "grid";
        console.log("Input wrapper displayed.");
      });
    } else {
      console.log("No conversation ID found. Hiding input wrapper.");
      chatInputWrapper.style.display = "none";
    }

    
    let conversationId = null;
    let isListening = false;
    let retainedText = "";
    
    function adjustHeight() {
      textarea.style.height = 'auto'; // Reset height
      textarea.style.height = `${textarea.scrollHeight}px`; // Set height based on scrollHeight
    }

        // Function to reset the textarea height and content
    function resetHeight() {
      textarea.value = "";
      textarea.style.height = "38px";
    }
    
    
    // Function to stop voice transcription
    function stopVoiceTranscription() {
      if (isListening) {
        recognition.stop();
        micButton.classList.remove("is-active");
        console.log("Voice transcription stopped.");
        isListening = false;
      }
      retainedText = "";
    }
    
    // Function to create a chat block (user or bot)
    function createChatBlock(isUser, content) {
      // Preprocess content to remove bullet points before { ... }
      content = content.replace(/(^|\n)[\s]*[-*]\s*(?=\{)/g, '$1');
      const segments = [];
      const regex = /(\{[\s\S]*?\})/g;
      let lastIndex = 0;
      let match;
    
      while ((match = regex.exec(content)) !== null) {
        if (match.index > lastIndex) {
          const textSegment = content.substring(lastIndex, match.index);
          segments.push({ type: "text", content: textSegment });
        }
        segments.push({ type: "option", content: match[1] });
        lastIndex = regex.lastIndex;
      }
    
      if (lastIndex < content.length) {
        const textSegment = content.substring(lastIndex);
        segments.push({ type: "text", content: textSegment });
      }
    
      let optionGroup = [];
      let lastOptionIndex = -1;
      let hasRenderedBotAvatar = false;
    
      segments.forEach((segment, index) => {
        if (segment.type === "text") {
          const textContent = segment.content.trim();
          if (textContent) {
            if (optionGroup.length > 0) {
              const isOptionsAtEnd = !hasNonEmptyTextAfterIndex(segments, lastOptionIndex);
              renderOptions(optionGroup, isOptionsAtEnd);
              optionGroup = [];
            }
            const hideAvatar = !isUser && hasRenderedBotAvatar;
            renderTextSegment(textContent, isUser, hideAvatar);
            hasRenderedBotAvatar = true;
          }
        } else if (segment.type === "option") {
          optionGroup.push(cleanOptionText(segment.content.slice(1, -1).trim()));
          lastOptionIndex = index;
        }
      });
    
      if (optionGroup.length > 0) {
        const isOptionsAtEnd = !hasNonEmptyTextAfterIndex(segments, lastOptionIndex);
        renderOptions(optionGroup, isOptionsAtEnd);
        optionGroup = [];
      }
    
      conversationWrapper.scrollTop = conversationWrapper.scrollHeight;
    }
    
    // Helper function to check if there's non-empty text after a given index
    function hasNonEmptyTextAfterIndex(segments, currentIndex) {
      for (let i = currentIndex + 1; i < segments.length; i++) {
        if (segments[i].type === "text" && segments[i].content.trim()) {
          return true;
        }
      }
      return false;
    }
    
    // Function to render a text segment in the chat
    function renderTextSegment(text, isUser, hideAvatar) {
      if (!text) return;
      const chatBlockWrapper = document.createElement("div");
      chatBlockWrapper.className = "chat_block-wrapper";
    
      const chatBlock = document.createElement("div");
      chatBlock.className = "chat_block";
    
      const botAvatar = document.createElement("div");
      botAvatar.className = "chat_bot-avatar";
      if (isUser || hideAvatar) botAvatar.classList.add("opacity-0");
    
      const userAvatar = document.createElement("div");
      userAvatar.className = "chat_user-avatar";
      if (!isUser) userAvatar.classList.add("opacity-0");
    
      const chatInnerWrapper = document.createElement("div");
      chatInnerWrapper.className = `chat_inner-wrapper ${isUser ? "user-message" : ""}`;
    
      const parsedHtml = marked.parse(text);
      const sanitizedHtml = DOMPurify.sanitize(parsedHtml);
    
      chatInnerWrapper.innerHTML = sanitizedHtml;
    
      chatBlock.appendChild(botAvatar);
      chatBlock.appendChild(chatInnerWrapper);
      chatBlock.appendChild(userAvatar);
    
      chatBlockWrapper.appendChild(chatBlock);
      conversationWrapper.appendChild(chatBlockWrapper);
    }
    
    // Function to render multiple choice options
    function renderOptions(options, isEnd) {
      if (options.length === 0) return;
    
      const chatBlockWrapper = document.createElement("div");
      chatBlockWrapper.className = "chat_block-wrapper is-multi-choice-options";
      if (isEnd) {
        chatBlockWrapper.classList.add("is-end");
      }
    
      const chatBlock = document.createElement("div");
      chatBlock.className = "chat_block is-multi-choice-options";
    
      let optionClicked = false;
    
      options.forEach((optionText) => {
        const optionDiv = document.createElement("div");
        optionDiv.className = "chat_multi-choice-option";
    
        const optionHeading = document.createElement("span");
        optionHeading.className = "chat-button-text";
        optionHeading.style.fontWeight = "bold"; // Apply bold styling
        optionHeading.textContent = optionText;
    
        optionDiv.appendChild(optionHeading);
        chatBlock.appendChild(optionDiv);
    
        // Handle option click
        optionDiv.addEventListener("click", async () => {
          if (optionClicked) return;
          optionDiv.classList.add("is-chosen");
          optionClicked = true;
          Array.from(chatBlock.children).forEach((child) => {
            if (child !== optionDiv) {
              child.classList.add("is-disabled");
              child.style.pointerEvents = "none";
            }
          });
    
          // Show the user's chosen option as their message
          createChatBlock(true, optionText);
    
          // Update Airtable Time-Last-Edited if record ID exists
          if (airtableRecordId) {
            console.log("Updating Time-Last-Edited for record ID:", airtableRecordId);
            await updateTimeLastEdited(airtableRecordId);
          }
    
          // Create loading block
          const { chatInnerWrapper: loadingWrapper, chatBlockWrapper: loadingBlockWrapper } = createLoadingBlock();
    
          // Get response
          const agentResponse = await startConversation(optionText);
    
          // Remove loading block
          conversationWrapper.removeChild(loadingBlockWrapper);
    
          // Show agent response
          createChatBlock(false, agentResponse);
        });
      });
    
      chatBlockWrapper.appendChild(chatBlock);
      conversationWrapper.appendChild(chatBlockWrapper);
    }

    
    // Function to clean option text
    function cleanOptionText(text) {
      text = text.replace(/^[\s]*([-*]|(\d+\.)|(\d+\))|[A-Z]\.)\s*/, ""); // Removes leading markers
      text = text.replace(/[*#_`~>]/g, ""); // Retain dashes, remove other unwanted symbols
      text = text.replace(/\s+/g, " ").trim(); // Normalizes whitespace
      return text;
    }

    
    async function startConversation(message) {
      try {
        const requestBody = {
          message: { role: "user", content: message },
          agent_id: agentId,
          ...(conversationId && { conversation_id: conversationId }), // Include conversationId if it exists
        };
    
        const response = await fetch(`${baseUrl}/agents/trigger`, {
          method: "POST",
          headers: headers,
          body: JSON.stringify(requestBody),
        });
    
        if (response.ok) {
          const data = await response.json();
    
          // Set conversationId only if it's a new conversation
          if (!conversationId) {
            conversationId = data.conversation_id;
            console.log(`New conversation started with ID: ${conversationId}`);
    
           
            console.log("New conversation started with ID:", conversationId);
          }
    
          const { studio_id, job_id } = data.job_info;
          const agentResponse = await pollAgentResponse(studio_id, job_id);
          return agentResponse;
        } else {
          const errorData = await response.json();
          console.error("Error starting conversation:", errorData);
          return `Sorry, something went wrong: ${errorData.message || response.statusText}`;
        }
      } catch (error) {
        console.error("Error starting conversation:", error);
        return "Sorry, something went wrong.";
      }
    }



    
    // Function to poll the AI for a response
    async function pollAgentResponse(studio_id, job_id) {
      const pollUrl = `${baseUrl}/studios/${studio_id}/async_poll/${job_id}`;
      let done = false;
    
      while (!done) {
        try {
          const response = await fetch(pollUrl, { method: "GET", headers: headers });
          if (response.ok) {
            const data = await response.json();
            for (const update of data.updates) {
              if (update.type === "chain-success" && update.output.status === "complete") {
                done = true;
                return update.output.output.answer;
              }
            }
          } else {
            console.error("Error during polling:", response.statusText);
            return "Sorry, something went wrong while waiting for the response.";
          }
        } catch (error) {
          console.error("Error during polling:", error);
          return "Sorry, something went wrong while waiting for the response.";
        }
        await new Promise((resolve) => setTimeout(resolve, 1000));
      }
    }
    
    // Function to create a loading block
    function createLoadingBlock() {
      const chatBlockWrapper = document.createElement("div");
      chatBlockWrapper.className = "chat_block-wrapper";
    
      const chatBlock = document.createElement("div");
      chatBlock.className = "chat_block";
    
      const botAvatar = document.createElement("div");
      botAvatar.className = "chat_bot-avatar";
    
      const chatInnerWrapper = document.createElement("div");
      chatInnerWrapper.className = "chat_inner-wrapper";
    
      // Create the loading animation container
      const loadAnimationContainer = document.createElement("div");
      loadAnimationContainer.className = "load-animation";
    
      // Use the GIF instead of a lottie
      const gifImage = document.createElement("img");
      gifImage.src = "https://cdn.prod.website-files.com/64e508e8bea103fa08b8f130/6761f50a16ce8196496d4724_load-animation.gif";
      gifImage.alt = "Loading...";
      loadAnimationContainer.appendChild(gifImage);
    
      chatInnerWrapper.appendChild(loadAnimationContainer);
      chatBlock.appendChild(botAvatar);
      chatBlock.appendChild(chatInnerWrapper);
      chatBlockWrapper.appendChild(chatBlock);
      conversationWrapper.appendChild(chatBlockWrapper);
      conversationWrapper.scrollTop = conversationWrapper.scrollHeight;
    
      return { chatInnerWrapper, chatBlockWrapper };
    }
    
    // Function to handle user message submission
    async function handleSubmit() {
      stopVoiceTranscription();
      const message = textarea.value.trim();
      if (!message) return;
    
      console.log("User submitted message:", message);
    
      // Update Time-Last-Edited in Airtable if recordId exists
      if (airtableRecordId) {
        console.log("Updating Time-Last-Edited for record ID:", airtableRecordId);
        await updateTimeLastEdited(airtableRecordId);
      }
    
      // Existing functionality to handle message submission
      createChatBlock(true, message); // Render user message
      resetHeight(); // Reset textarea height
    
      // Display loading block
      const { chatInnerWrapper, chatBlockWrapper } = createLoadingBlock();
    
      // Get AI response
      const agentResponse = await startConversation(message);
    
      // Remove loading block
      conversationWrapper.removeChild(chatBlockWrapper);
    
      // Render AI response
      createChatBlock(false, agentResponse);
    }

    
    // Attach event listeners
    textarea.addEventListener("input", adjustHeight);
    userSubmit.addEventListener("click", handleSubmit);
    
    textarea.addEventListener("keydown", (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key === "Enter") {
        e.preventDefault();
        handleSubmit();
      }
    });
    
    // Initialize speech recognition
    const recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
    recognition.continuous = true;
    recognition.interimResults = true;
    recognition.lang = "en-US";
    
    recognition.onresult = (event) => {
      let interimTranscript = "";
      let finalTranscript = "";
    
      for (let i = event.resultIndex; i < event.results.length; ++i) {
        if (event.results[i].isFinal) {
          finalTranscript += event.results[i][0].transcript;
          retainedText += event.results[i][0].transcript;
        } else {
          interimTranscript += event.results[i][0].transcript;
        }
      }
    
      textarea.value = retainedText + interimTranscript;
      adjustHeight();
    };
    
    recognition.onstart = () => {
      console.log("Speech recognition started.");
    };
    
    recognition.onend = () => {
      console.log("Speech recognition ended.");
      micButton.classList.remove("is-active");
      isListening = false;
    };
    
    recognition.onerror = (event) => {
      console.error("Speech recognition error:", event.error);
      micButton.classList.remove("is-active");
      isListening = false;
    };
    
    // Attach event listener to micButton
    if (micButton) {
      micButton.addEventListener("click", () => {
        console.log("Mic button clicked.");
        if (isListening) {
          recognition.stop();
          micButton.classList.remove("is-active");
          console.log("Stopped listening.");
        } else {
          retainedText = textarea.value;
          recognition.start();
          micButton.classList.add("is-active");
          console.log("Started listening.");
        }
        isListening = !isListening;
      });
    } else {
      console.error("Cannot find #chat-user-input-mic element.");
    }
    
    // -----------------------------
    // Automatically Start Conversation
    // -----------------------------
    async function startInitialConversation() {
      // Clear existing chat blocks
      while (conversationWrapper.firstChild) {
        conversationWrapper.removeChild(conversationWrapper.firstChild);
      }
      console.log("Cleared existing chat blocks.");
    
      // Remove conversationID from the URL
      const url = new URL(window.location.href);
      url.searchParams.delete('conversationID');
      window.history.replaceState({}, '', url);
      console.log("Removed conversationID from URL.");
    
      // Reset the global conversationId variable
      conversationId = null;
      console.log("Reset conversationId to null.");
    
      // Create loading block
      const { chatInnerWrapper, chatBlockWrapper } = createLoadingBlock();
    
      // Construct the initial message
      const currentTime = new Date().toLocaleString();
      const initialMessage = `conversation_name=${currentTime}, current_username=${name}, current_user_email=${email}`;
      console.log("Sending initial message to AI:", initialMessage);
    
      // Send the initial message to AI
      const agentResponse = await startConversation(initialMessage);
    
      // Remove loading block
      conversationWrapper.removeChild(chatBlockWrapper);
    
      // Display only the AI's response
      createChatBlock(false, agentResponse);
    
      // Save metadata to Airtable after the conversation is initialized
      const metadata = {
        userName: name,
        agentID: agentId,
        conversationID: conversationId,
        timeStamp: new Date().toISOString(),
        userId: "aabcdefheja", // Example User ID
      };
    
      try {
        const savedRecord = await saveConversationToAirtable(metadata);
        if (savedRecord && savedRecord.id) {
          airtableRecordId = savedRecord.id; // Save the Airtable record ID globally
          console.log("Airtable record successfully saved. Record ID:", airtableRecordId);
        } else {
          console.error("Failed to retrieve Airtable record ID after saving.");
        }
      } catch (error) {
        console.error("Error saving conversation metadata to Airtable:", error);
      }
    
      // Show the input UI so the user can continue
      if (chatInputWrapper) {
        chatInputWrapper.style.display = "grid";
        console.log("Input wrapper displayed as grid.");
      }
    }



    
    const startConversationButton = document.getElementById('start-new-conversation');
    if (startConversationButton) {
      startConversationButton.addEventListener('click', async (event) => {
        event.preventDefault();
        console.log('Starting a new conversation...');
    
        // Start a new conversation
        await startInitialConversation(); // Existing function to start the conversation
    
        // Collect metadata
        const container = document.getElementById('ai-agent-container');
        const userName = container.getAttribute('data-user-name') || 'Guest';
        const agentID = container.getAttribute('data-agent-id') || 'Unknown Agent';
        const timeStamp = new Date().toISOString(); // Current date/time in ISO format
    
        const metadata = {
          userName,
          agentID,
          conversationID: conversationId || 'Unknown Conversation ID',
          timeStamp,
          userId, // Include globally accessible User-ID
        };
    
        // Only save to Airtable if userId is not null
        if (userId) {
          await saveConversationToAirtable(metadata);
        } else {
          console.log('User-ID is null. Skipping metadata save to Airtable.');
        }
      });
    } else {
      console.error("Button with id 'start-new-conversation' not found.");
    }


  })();
</script>
