<script type="text/javascript">!function(o,c){var n=c.documentElement,t=" w-mod-";n.className+=t+"js",("ontouchstart"in o||o.DocumentTouch&&c instanceof DocumentTouch)&&(n.className+=t+"touch")}(window,document);</script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/dompurify/dist/purify.min.js"></script>
<div class="chat-bot_styles w-embed">
</div>
<div class="page-wrapper is-app is-ami">
  <div class="main-wrapper">
    <div class="shell15_wrapper">
      <main class="shell15_main-wrapper">
        <div id="chat_conversation-wrapper" class="chat_conversation-wrapper"></div>
        <div class="chat_input-wrapper">
          <div id="chat-file-input" class="chat_input-button">
            <!-- File upload icon -->
            <div id="chat-file-input-icon" class="icon-embed-small w-embed">
              <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--ic" width="100%" height="100%" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24">
                <path fill="currentColor" d="M16.5 6v11.5c0 2.21-1.79 4-4 4s-4-1.79-4-4V5a2.5 2.5 0 0 1 5 0v10.5c0 .55-.45 1-1 1s-1-.45-1-1V6H10v9.5a2.5 2.5 0 0 0 5 0V5c0-2.21-1.79-4-4-4S7 2.79 7 5v12.5c0 3.04 2.46 5.5 5.5 5.5s5.5-2.46 5.5-5.5V6z"></path>
              </svg>
            </div>
            <!-- Loading animation GIF -->
            <img id="chat-file-loading" src="https://member.archmarketing.org/wp-content/uploads/2025/01/ZKZg.gif" alt="Loading..." style="display: none; width: 24px; height: 24px;">
          </div>
          <div id="chat-user-input-mic" class="chat_input-button w-node-d52fb02a-d5b0-6fa8-115b-d486e3e4b322-8f158f72">
            <div class="icon-embed-small w-embed"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--ic" width="100%" height="100%" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24">
                <path fill="currentColor" d="M12 15c1.66 0 2.99-1.34 2.99-3L15 6c0-1.66-1.34-3-3-3S9 4.34 9 6v6c0 1.66 1.34 3 3 3m-1.2-9.1c0-.66.54-1.2 1.2-1.2s1.2.54 1.2 1.2l-.01 6.2c0 .66-.53 1.2-1.19 1.2s-1.2-.54-1.2-1.2zm6.5 6.1c0 3-2.54 5.1-5.3 5.1S6.7 15 6.7 12H5c0 3.41 2.72 6.23 6 6.72V22h2v-3.28c3.28-.48 6-3.3 6-6.72z"></path>
              </svg></div>
          </div>
          <div id="chat-voice-toggle" class="chat_input-button">
            <div class="icon-embed-small w-embed">
              <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--bx" width="32" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24">
                <path fill="currentColor" d="M8 12c2.28 0 4-1.72 4-4s-1.72-4-4-4s-4 1.72-4 4s1.72 4 4 4m0-6c1.178 0 2 .822 2 2s-.822 2-2 2s-2-.822-2-2s.822-2 2-2m1 7H7c-2.757 0-5 2.243-5 5v1h2v-1c0-1.654 1.346-3 3-3h2c1.654 0 3 1.346 3 3v1h2v-1c0-2.757-2.243-5-5-5m9.364-10.364L16.95 4.05C18.271 5.373 19 7.131 19 9s-.729 3.627-2.05 4.95l1.414 1.414C20.064 13.663 21 11.403 21 9s-.936-4.663-2.636-6.364"></path>
                <path fill="currentColor" d="M15.535 5.464L14.121 6.88C14.688 7.445 15 8.198 15 9s-.312 1.555-.879 2.12l1.414 1.416C16.479 11.592 17 10.337 17 9s-.521-2.592-1.465-3.536"></path>
              </svg>
            </div>
          </div>
          <div id="w-node-_819b1fcb-bef5-c69d-b33b-f104bd5e9695-8f158f72" class="chat_input-text">
            <div id="w-node-_256faa1f-1943-6b85-6f8e-bd7a8a4af011-8f158f72" class="code-embed-2 w-embed">
              <div class="form-input is-app">
                <textarea id="chat-user-input" class="textarea-dynamic" rows="1" placeholder="Type your message here..."></textarea>
              </div>
            </div>
          </div>
          <div id="chat-user-submit" class="button is-app w-node-_4bf83d64-1477-4e83-8a98-23560ff07d2d-8f158f72 w-inline-block" draggable="false">
            <div class="chat_submit-input w-embed"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--heroicons" width="100%" height="100%" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24">
                <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M6 12L3.269 3.125A59.8 59.8 0 0 1 21.486 12a59.8 59.8 0 0 1-18.217 8.875zm0 0h7.5"></path>
              </svg></div>
          </div>
        </div>
      </main>
    </div>
  </div>
</div>


<!-- Existing HTML structure remains unchanged -->

<script>
  // Immediately execute the chatbot initialization code
  (function() {
    console.log("Chatbot initialized.");

    // 1) Get the container in which this HTML was injected
    const container = document.getElementById("ai-agent-container");
    
    // 2) Read data attributes (fallback to defaults if missing)
    const agentId = container?.getAttribute("data-agent-id") || "6a12b1cd-b7d5-4b00-80ee-d2829af810dc";
    const name    = container?.getAttribute("data-user-name") || "Guest";
    const email   = container?.getAttribute("data-user-email") || "noemail@domain.com";
    
    // Configuration for AI agent
    const region = "bcbe5a"; // Replace with your region
    const projectId = "c5bf489c1af9-4886-afba-073965a5ad71"; // Replace with your project ID
    const apiKey = "sk-MGJlOWM0NGEtMjgyNC00MTIwLTg5NGUtN2IwMzljMmNjNDgx"; // Replace with your API key
    
    // Use base64 encoding for the authorization token
    const authorizationToken = `Basic ${btoa(`${projectId}:${apiKey}`)}`;
    const baseUrl = `https://api-${region}.stack.tryrelevance.com/latest`;
    const headers = {
      Authorization: authorizationToken,
      "Content-Type": "application/json",
    };
    
    // DOM elements
    const textarea = document.getElementById("chat-user-input");
    const micButton = document.getElementById("chat-user-input-mic");
    const userSubmit = document.getElementById("chat-user-submit");
    const conversationWrapper = document.getElementById("chat_conversation-wrapper");
    const chatInputWrapper = document.querySelector(".chat_input-wrapper");

    const urlParams = new URLSearchParams(window.location.search);
    const conversationID = urlParams.get('conversationID');

    let airtableRecordId = null;

    // Function to handle PDF upload and append the URL to the input field
    function handlePdfUpload() {
      // Create a hidden file input element for selecting PDFs
      const fileInput = document.createElement("input");
      fileInput.type = "file";
      fileInput.accept = "application/pdf"; // Restrict to PDF files only
      fileInput.style.display = "none";
    
      // DOM Elements for toggling visibility
      const fileIcon = document.getElementById("chat-file-input-icon");
      const loadingGif = document.getElementById("chat-file-loading");
      const userInput = document.getElementById("chat-user-input");
    
      // Listen for file selection
      fileInput.addEventListener("change", async (event) => {
        const file = event.target.files[0];
        if (!file) return;
    
        // Validate file type
        if (file.type !== "application/pdf") {
          alert("Please select a valid PDF file.");
          return;
        }
    
        try {
          // Show the loading animation and hide the file icon
          fileIcon.style.display = "none";
          loadingGif.style.display = "block";
    
          // Prepare FormData for Cloudinary upload
          const formData = new FormData();
          formData.append("file", file);
          formData.append("upload_preset", "my_unsigned_preset"); // Use your unsigned preset name
    
          // Upload the PDF to Cloudinary
          const response = await fetch("https://api.cloudinary.com/v1_1/dgt84jatm/auto/upload", {
            method: "POST",
            body: formData,
          });
    
          if (!response.ok) {
            throw new Error("Failed to upload the PDF to Cloudinary");
          }
    
          // Parse the response JSON
          const data = await response.json();
    
          // Extract the secure URL of the uploaded PDF
          const pdfUrl = data.secure_url;
    
          // Format the output for the textarea
          const formattedOutput = `(PDF: ${pdfUrl})`;
    
          // Append the formatted output to the chat-user-input textarea
          userInput.value += ` ${formattedOutput}`;
    
          // Dynamically adjust the textarea height
          adjustHeight();
        } catch (error) {
          console.error("Error uploading PDF:", error);
          alert("There was an issue uploading your PDF. Please try again.");
        } finally {
          // Hide the loading animation and show the file icon again
          fileIcon.style.display = "block";
          loadingGif.style.display = "none";
        }
      });
    
      // Trigger the file input dialog
      fileInput.click();
    }

    // Attach the event listener to the chat-file-input button
    const chatFileInputButton = document.getElementById("chat-file-input");
    if (chatFileInputButton) {
      chatFileInputButton.addEventListener("click", handlePdfUpload);
    } else {
      console.error("Button with ID 'chat-file-input' not found.");
    }


    function stopCurrentVoiceOutput() {
        if (currentAudio) {
            currentAudio.pause(); // Stop playback
            currentAudio = null;  // Release the audio instance
            console.log("Current voice output stopped.");
        }
    }


    // Utility function to convert Markdown to plain text
    function markdownToPlainText(markdown) {
        // Ensure the `marked` object is correctly accessed
        const parser = typeof marked === "function" ? marked : marked.parse;
    
        // Parse Markdown to HTML
        const html = parser(markdown);
    
        // Sanitize the HTML
        const sanitizedHtml = DOMPurify.sanitize(html);
    
        // Create a temporary DOM element to extract plain text
        const tempDiv = document.createElement("div");
        tempDiv.innerHTML = sanitizedHtml;
    
        // Return plain text content
        return tempDiv.textContent || tempDiv.innerText || "";
    }



    if (conversationID) {
      console.log("Conversation ID found in URL:", conversationID);
      fetchAirtableRecordId(conversationID).then(() => {
        console.log("Airtable Record ID set from existing conversation ID:", airtableRecordId);
      });
    } else {
      console.log("No conversation ID provided in the URL. Waiting for user to start a new conversation.");
    }



    // Fetch Airtable record ID based on the conversationID
    async function fetchAirtableRecordId(conversationID) {
      const airtableBaseUrl = 'https://api.airtable.com/v0/app2N6x5jeRnIzSpL/Conversations';
      const airtableHeaders = {
        Authorization: 'Bearer patTeuxUuzgG0ZU8Q.2eb9ff7f31afe3e06f3c128c5b5b832bcc4e4e85bd58a5007a8368f218d28b83',
        'Content-Type': 'application/json',
      };
    
      try {
        const response = await fetch(`${airtableBaseUrl}?filterByFormula={Conversation-ID}="${conversationID}"`, {
          method: 'GET',
          headers: airtableHeaders,
        });
    
        if (response.ok) {
          const data = await response.json();
          if (data.records && data.records.length > 0) {
            airtableRecordId = data.records[0].id; // Save the record ID
            console.log("Fetched Airtable Record ID:", airtableRecordId);
          } else {
            console.log("No matching Airtable record found for Conversation-ID:", conversationID);
          }
        } else {
          console.error("Error fetching Airtable record ID:", await response.text());
        }
      } catch (error) {
        console.error("Error during Airtable record ID fetch:", error);
      }
    }

    async function updateTimeLastEdited(recordId) {
      const airtableBaseUrl = 'https://api.airtable.com/v0/app2N6x5jeRnIzSpL/Conversations';
      const airtableHeaders = {
        Authorization: 'Bearer patTeuxUuzgG0ZU8Q.2eb9ff7f31afe3e06f3c128c5b5b832bcc4e4e85bd58a5007a8368f218d28b83',
        'Content-Type': 'application/json',
      };
    
      try {
        const response = await fetch(`${airtableBaseUrl}/${recordId}`, {
          method: 'PATCH',
          headers: airtableHeaders,
          body: JSON.stringify({
            fields: {
              'Time-Last-Edited': new Date().toISOString(), // Current time in GMT
            },
          }),
        });
    
        if (response.ok) {
          console.log("Successfully updated Time-Last-Edited:", await response.json());
        } else {
          console.error("Error updating Time-Last-Edited:", await response.text());
        }
      } catch (error) {
        console.error("Error during PATCH request:", error);
      }
    }


        // Function to fetch profile image from Airtable
    async function fetchAgentProfileImage(agentId) {
      try {
        const airtableBaseUrl = 'https://api.airtable.com/v0/app2N6x5jeRnIzSpL/Agents';
        const airtableHeaders = {
          Authorization: 'Bearer patTeuxUuzgG0ZU8Q.2eb9ff7f31afe3e06f3c128c5b5b832bcc4e4e85bd58a5007a8368f218d28b83',
          'Content-Type': 'application/json',
        };
    
        const response = await fetch(`${airtableBaseUrl}?filterByFormula={Agent-ID}="${agentId}"`, {
          method: 'GET',
          headers: airtableHeaders,
        });
    
        if (response.ok) {
          const data = await response.json();
          if (data.records && data.records.length > 0) {
            const profileImage = data.records[0].fields['Profile-Image'][0].url;
            console.log("Profile Image URL:", profileImage);
            return profileImage;
          } else {
            console.log("No record found for Agent-ID:", agentId);
            return null;
          }
        } else {
          console.error("Failed to fetch data from Airtable:", await response.text());
          return null;
        }
      } catch (error) {
        console.error("Error fetching profile image from Airtable:", error);
        return null;
      }
    }
    
    function updateChatBotAvatarStyle(profileImage) {
      if (profileImage) {
        const style = document.createElement('style');
        style.textContent = `
          .chat_bot-avatar {
            background-image: url("${profileImage}") !important;
            background-size: cover !important;
            background-position: center !important;
            background-repeat: no-repeat !important;
          }
        `;
        document.head.appendChild(style);
        console.log("Updated chat_bot-avatar style globally with !important.");
      } else {
        console.log("No profile image provided, skipping style update.");
      }
    }

    
    // Initialize the process
    (async function initializeChatBot() {
      const agentId = container?.getAttribute("data-agent-id") || "6a12b1cd-b7d5-4b00-80ee-d2829af810dc";
      const profileImage = await fetchAgentProfileImage(agentId);
      updateChatBotAvatarStyle(profileImage);
    })();


    // Function to fetch user profile image from Airtable using Email
    async function fetchUserProfileImageByEmail(email) {
      try {
        const airtableBaseUrl = 'https://api.airtable.com/v0/app2N6x5jeRnIzSpL/Users'; // Replace with your actual base
        const airtableHeaders = {
          Authorization: 'Bearer patTeuxUuzgG0ZU8Q.2eb9ff7f31afe3e06f3c128c5b5b832bcc4e4e85bd58a5007a8368f218d28b83',
          'Content-Type': 'application/json',
        };
    
        // Use the email to filter records
        const response = await fetch(`${airtableBaseUrl}?filterByFormula={Email}="${email}"`, {
          method: 'GET',
          headers: airtableHeaders,
        });
    
        if (response.ok) {
          const data = await response.json();
          if (data.records && data.records.length > 0) {
            const profileImage = data.records[0].fields['Profile-Image'][0].url;
            console.log("User Profile Image URL:", profileImage);
            return profileImage;
          } else {
            console.log("No record found for Email:", email);
            return null;
          }
        } else {
          console.error("Failed to fetch data from Airtable:", await response.text());
          return null;
        }
      } catch (error) {
        console.error("Error fetching user profile image from Airtable:", error);
        return null;
      }
    }
    
    // Function to update the global style for chat_user-avatar
    function updateChatUserAvatarStyle(profileImage) {
      if (profileImage) {
        const style = document.createElement('style');
        style.textContent = `
          .chat_user-avatar {
            background-image: url("${profileImage}") !important;
            background-size: cover !important;
            background-position: center !important;
            background-repeat: no-repeat !important;
          }
        `;
        document.head.appendChild(style);
        console.log("Updated chat_user-avatar style globally with !important.");
      } else {
        console.log("No user profile image provided, skipping style update.");
      }
    }
    
    // Initialize the process for user profile image
    (async function initializeUserAvatar() {
      const userProfileImage = await fetchUserProfileImageByEmail(email); // Use the email variable defined in the code
      updateChatUserAvatarStyle(userProfileImage);
    })();


    async function saveConversationToAirtable(metadata) {
      const conversationsTableUrl = 'https://api.airtable.com/v0/app2N6x5jeRnIzSpL/conversations';
      const airtableHeaders = {
        Authorization: 'Bearer patTeuxUuzgG0ZU8Q.2eb9ff7f31afe3e06f3c128c5b5b832bcc4e4e85bd58a5007a8368f218d28b83',
        'Content-Type': 'application/json',
      };
    
      try {
        const response = await fetch(conversationsTableUrl, {
          method: 'POST',
          headers: airtableHeaders,
          body: JSON.stringify({
            fields: {
              'Client-Name': metadata.userName,
              'Agent-ID': metadata.agentID,
              'Conversation-ID': metadata.conversationID,
              'Time-Stamp': metadata.timeStamp,
              'User-ID': metadata.userId, // Include the User-ID
            },
          }),
        });
    
        if (response.ok) {
          const data = await response.json();
          console.log('Conversation metadata saved successfully:', data);
          return data.id; // Return the record ID
        } else {
          console.error('Failed to save conversation metadata:', await response.text());
          return null;
        }
      } catch (error) {
        console.error('Error saving conversation metadata to Airtable:', error);
        return null;
      }
    }



    // Function to fetch and log conversation messages
    async function fetchConversationMessages(conversationID) {
      if (!conversationID) {
        console.log("No conversationID provided.");
        return;
      }
    
      try {
        const response = await fetch(`${baseUrl}/knowledge/list`, {
          method: "POST",
          headers: {
            Authorization: authorizationToken,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            knowledge_set: conversationID,
            page_size: 999, // Adjust as needed
            sort: [{ insert_date_: "desc" }], // Newest message first
          }),
        });
    
        if (!response.ok) {
          console.error("Error fetching conversation:", await response.text());
          return;
        }
    
        const data = await response.json();
        const messages = data.results || [];
    
        console.log("Fetched conversation messages:", messages);
        return messages;
      } catch (error) {
        console.error("Error accessing Relevance API:", error);
      }
    }
    

    // Function to render conversation messages in the chat UI
    function renderConversationMessages(messages) {
      if (!Array.isArray(messages) || messages.length === 0) {
        console.log("No messages to render.");
        return;
      }
    
      // Reverse the order to render messages in chronological order
      messages.reverse();
    
      // Skip the first user message if it exists
      const filteredMessages = messages.filter((message, index) => {
        const role = message?.data?.message?.role;
        // Exclude the very first user message
        return !(index === 0 && role === "user");
      });
    
      // Render the remaining messages
      filteredMessages.forEach((message) => {
        const role = message?.data?.message?.role;
        const content = message?.data?.message?.content;
    
        if (role && content) {
          const isUser = role === "user";
          createChatBlock(isUser, content);
        }
      });
    
      // Scroll to the bottom of the conversation
      conversationWrapper.scrollTop = conversationWrapper.scrollHeight;
    }


    
    if (conversationID) {
      console.log("Conversation ID found:", conversationID);
    
      // Fetch and render messages
      fetchConversationMessages(conversationID).then((messages) => {
        if (messages) {
          renderConversationMessages(messages);
          conversationId = conversationID; // Set global conversationId here
          console.log("Global conversationId set to:", conversationId);
        } else {
          console.error("Failed to fetch conversation messages.");
        }
    
        // Show the input wrapper after messages are loaded
        chatInputWrapper.style.display = "grid";
        console.log("Input wrapper displayed.");
      });
    } else {
      console.log("No conversation ID found. Hiding input wrapper.");
      chatInputWrapper.style.display = "none";
    }

    
    let conversationId = null;
    let isListening = false;
    let finalSoFar = "";   // Will store all finalized recognized text.
    let lastPartial = "";  // Will track the most recently appended partial text.

    
    function adjustHeight() {
      textarea.style.height = 'auto'; // Reset height
      textarea.style.height = `${textarea.scrollHeight}px`; // Set height based on scrollHeight
    }

        // Function to reset the textarea height and content
    function resetHeight() {
      textarea.value = "";
      textarea.style.height = "38px";
    }
    
    
    // Function to stop voice transcription
    function stopVoiceTranscription() {
      if (isListening) {
        recognition.stop();
        micButton.classList.remove("is-active");
        console.log("Voice transcription stopped.");
        isListening = false;
      }
    }
    
    // Function to create a chat block (user or bot)
    function createChatBlock(isUser, content) {
      // Preprocess content to remove bullet points before { ... }
      content = content.replace(/(^|\n)[\s]*[-*]\s*(?=\{)/g, '$1');
      const segments = [];
      const regex = /(\{[\s\S]*?\})/g;
      let lastIndex = 0;
      let match;
    
      while ((match = regex.exec(content)) !== null) {
        if (match.index > lastIndex) {
          const textSegment = content.substring(lastIndex, match.index);
          segments.push({ type: "text", content: textSegment });
        }
        segments.push({ type: "option", content: match[1] });
        lastIndex = regex.lastIndex;
      }
    
      if (lastIndex < content.length) {
        const textSegment = content.substring(lastIndex);
        segments.push({ type: "text", content: textSegment });
      }
    
      let optionGroup = [];
      let lastOptionIndex = -1;
      let hasRenderedBotAvatar = false;
    
      segments.forEach((segment, index) => {
        if (segment.type === "text") {
          const textContent = segment.content.trim();
          if (textContent) {
            if (optionGroup.length > 0) {
              const isOptionsAtEnd = !hasNonEmptyTextAfterIndex(segments, lastOptionIndex);
              renderOptions(optionGroup, isOptionsAtEnd);
              optionGroup = [];
            }
            const hideAvatar = !isUser && hasRenderedBotAvatar;
            renderTextSegment(textContent, isUser, hideAvatar);
            hasRenderedBotAvatar = true;
          }
        } else if (segment.type === "option") {
          optionGroup.push((segment.content.slice(1, -1).trim()));
          lastOptionIndex = index;
        }
      });
    
      if (optionGroup.length > 0) {
        const isOptionsAtEnd = !hasNonEmptyTextAfterIndex(segments, lastOptionIndex);
        renderOptions(optionGroup, isOptionsAtEnd);
        optionGroup = [];
      }
    
      conversationWrapper.scrollTop = conversationWrapper.scrollHeight;
    }
    
    // Helper function to check if there's non-empty text after a given index
    function hasNonEmptyTextAfterIndex(segments, currentIndex) {
      for (let i = currentIndex + 1; i < segments.length; i++) {
        if (segments[i].type === "text" && segments[i].content.trim()) {
          return true;
        }
      }
      return false;
    }
    
    // Function to render a text segment in the chat
    function renderTextSegment(text, isUser, hideAvatar) {
      if (!text) return;
      const chatBlockWrapper = document.createElement("div");
      chatBlockWrapper.className = "chat_block-wrapper";
    
      const chatBlock = document.createElement("div");
      chatBlock.className = "chat_block";
    
      const botAvatar = document.createElement("div");
      botAvatar.className = "chat_bot-avatar";
      if (isUser || hideAvatar) botAvatar.classList.add("opacity-0");
    
      const userAvatar = document.createElement("div");
      userAvatar.className = "chat_user-avatar";
      if (!isUser) userAvatar.classList.add("opacity-0");
    
      const chatInnerWrapper = document.createElement("div");
      chatInnerWrapper.className = `chat_inner-wrapper ${isUser ? "user-message" : ""}`;
    
      const parsedHtml = marked.parse(text);
      const sanitizedHtml = DOMPurify.sanitize(parsedHtml);
    
      chatInnerWrapper.innerHTML = sanitizedHtml;
    
      chatBlock.appendChild(botAvatar);
      chatBlock.appendChild(chatInnerWrapper);
      chatBlock.appendChild(userAvatar);
    
      chatBlockWrapper.appendChild(chatBlock);
      conversationWrapper.appendChild(chatBlockWrapper);
    }
    
    /**
     * Renders multiple choice options in the chat UI.
     * 
     * Dependencies/Variables:
     *  - conversationWrapper (DOM element)
     *  - stopCurrentVoiceOutput() 
     *  - createChatBlock(isUser, text)
     *  - airtableRecordId, updateTimeLastEdited(recordId)
     *  - createLoadingBlock()
     *  - startConversation(message)
     *  - adjustHeight() – adjusts the textarea height
     *  - chat-user-input (the <textarea> element)
     */
    
    function renderOptions(options, isEnd) {
      if (options.length === 0) return;
    
      // Create a container for the multi-choice block
      const chatBlockWrapper = document.createElement("div");
      chatBlockWrapper.className = "chat_block-wrapper is-multi-choice-options";
      if (isEnd) {
        chatBlockWrapper.classList.add("is-end");
      }
    
      const chatBlock = document.createElement("div");
      chatBlock.className = "chat_block is-multi-choice-options";
    
      let optionClicked = false;
    
      options.forEach((optionText) => {
        // 1. Container for icon + main option
        const optionContainer = document.createElement("div");
        optionContainer.className = "chat_multi-choice-container";
    
        const clipboardIcon = document.createElement("span");
        clipboardIcon.className = "clipboard-icon";
        clipboardIcon.innerHTML = `
          <svg xmlns="http://www.w3.org/2000/svg" 
               aria-hidden="true" 
               role="img" 
               class="clipboard-svg" 
               width="32" 
               height="32" 
               viewBox="0 0 24 24">
            <path fill="currentColor" 
                  d="M15 20H5V7c0-.55-.45-1-1-1s-1 .45-1 1v13c0 1.1.9 2 2 2h10c.55 0 1-.45 1-1s-.45-1-1-1m5-4V4c0-1.1-.9-2-2-2H9c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h9c1.1 0 2-.9 2-2m-2 0H9V4h9z">
            </path>
          </svg>`;
    
        // 3. The main clickable option (original button)
        const optionDiv = document.createElement("div");
        optionDiv.className = "chat_multi-choice-option";
    
        const optionHeading = document.createElement("span");
        optionHeading.className = "chat-button-text";
        optionHeading.style.fontWeight = "bold"; 
        optionHeading.textContent = optionText;
    
        optionDiv.appendChild(optionHeading);
    
        // Add icon + option to the container
        optionContainer.appendChild(clipboardIcon);
        optionContainer.appendChild(optionDiv);
    
        // Add container to the overall chat block
        chatBlock.appendChild(optionContainer);
    
        // --- CLIPBOARD ICON CLICK (NEW/UPDATED) ---
        clipboardIcon.addEventListener("click", (e) => {
          e.stopPropagation(); // Prevent triggering the send-text logic
    
          // 1) Copy the option text to clipboard
          navigator.clipboard.writeText(optionText)
            .then(() => {
              // Switch to tick for 2 seconds
              clipboardIcon.innerHTML = "✅";
              setTimeout(() => {
                  clipboardIcon.innerHTML = `
                      <svg xmlns="http://www.w3.org/2000/svg" 
                           aria-hidden="true" 
                           role="img" 
                           class="clipboard-svg" 
                           width="32" 
                           height="32" 
                           viewBox="0 0 24 24">
                          <path fill="currentColor" 
                                d="M15 20H5V7c0-.55-.45-1-1-1s-1 .45-1 1v13c0 1.1.9 2 2 2h10c.55 0 1-.45 1-1s-.45-1-1-1m5-4V4c0-1.1-.9-2-2-2H9c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h9c1.1 0 2-.9 2-2m-2 0H9V4h9z">
                          </path>
                      </svg>`;
              }, 2000);
            })
            .catch((err) => {
              console.error("Clipboard copy failed:", err);
            });
    
          // 2) ALSO append the text to the user's input area with a line break
          const userInput = document.getElementById("chat-user-input");
          userInput.value += `${optionText}\n`;
          adjustHeight(); // Re-adjust textarea size if needed
        });
    
        // --- MAIN OPTION CLICK (unchanged) ---
        optionDiv.addEventListener("click", async () => {
          if (optionClicked) return;
          optionDiv.classList.add("is-chosen");
          optionClicked = true;
    
          // Disable other options
          Array.from(chatBlock.children).forEach((child) => {
            if (child !== optionContainer) {
              child.classList.add("is-disabled");
              child.style.pointerEvents = "none";
            }
          });
    
          // Stop current voice output
          stopCurrentVoiceOutput();
    
          // Show user-chosen option in the chat
          createChatBlock(true, optionText);
    
          // Update Airtable time if record ID exists
          if (airtableRecordId) {
            console.log("Updating Time-Last-Edited for record ID:", airtableRecordId);
            await updateTimeLastEdited(airtableRecordId);
          }
    
          // Show loading block
          const { chatInnerWrapper: loadingWrapper, chatBlockWrapper: loadingBlockWrapper } = createLoadingBlock();
    
          // Send the text to the agent, get response
          const agentResponse = await startConversation(optionText);
    
          // Remove loading block, show response
          conversationWrapper.removeChild(loadingBlockWrapper);
          createChatBlock(false, agentResponse);
        });
      });
    
      chatBlockWrapper.appendChild(chatBlock);
      conversationWrapper.appendChild(chatBlockWrapper);
    }



    
    // Function to clean option text
    function cleanOptionText(text) {
      // Only remove bullet points '-' or '*'
      text = text.replace(/^[\s]*[-*]\s*/, "");
      text = text.replace(/[*#_`~>]/g, ""); // Retain dashes, remove other unwanted symbols
      text = text.replace(/\s+/g, " ").trim(); // Normalizes whitespace
      return text;
    }

    
    // Function to start a conversation with the AI
    async function startConversation(message) {
      try {
        const requestBody = {
          message: { role: "user", content: message },
          agent_id: agentId,
          ...(conversationId && { conversation_id: conversationId }) // Include conversationId if it exists
        };
    
        const response = await fetch(`${baseUrl}/agents/trigger`, {
          method: "POST",
          headers: headers,
          body: JSON.stringify(requestBody),
        });
    
        if (response.ok) {
          const data = await response.json();
    
          // Set conversationId only if it's a new conversation
          if (!conversationId) {
            conversationId = data.conversation_id;
            console.log(`New conversation started with ID: ${conversationId}`);
          }
    
          const { studio_id, job_id } = data.job_info;
          const agentResponse = await pollAgentResponse(studio_id, job_id);
          return agentResponse;
        } else {
          const errorData = await response.json();
          console.error("Error starting conversation:", errorData);
          return `Sorry, something went wrong: ${errorData.message || response.statusText}`;
        }
      } catch (error) {
        console.error("Error starting conversation:", error);
        return "Sorry, something went wrong.";
      }
    }


    
    // Function to poll the AI for a response
    async function pollAgentResponse(studio_id, job_id) {
      const pollUrl = `${baseUrl}/studios/${studio_id}/async_poll/${job_id}`;
      let done = false;
    
      while (!done) {
        try {
          const response = await fetch(pollUrl, { method: "GET", headers: headers });
          if (response.ok) {
            const data = await response.json();
            for (const update of data.updates) {
              if (update.type === "chain-success" && update.output.status === "complete") {
                done = true;
                return update.output.output.answer;
              }
            }
          } else {
            console.error("Error during polling:", response.statusText);
            return "Sorry, something went wrong while waiting for the response.";
          }
        } catch (error) {
          console.error("Error during polling:", error);
          return "Sorry, something went wrong while waiting for the response.";
        }
        await new Promise((resolve) => setTimeout(resolve, 1000));
      }
    }
    
    // Function to create a loading block
    function createLoadingBlock() {
      const chatBlockWrapper = document.createElement("div");
      chatBlockWrapper.className = "chat_block-wrapper";
    
      const chatBlock = document.createElement("div");
      chatBlock.className = "chat_block";
    
      const botAvatar = document.createElement("div");
      botAvatar.className = "chat_bot-avatar";
    
      const chatInnerWrapper = document.createElement("div");
      chatInnerWrapper.className = "chat_inner-wrapper";
    
      // Create the loading animation container
      const loadAnimationContainer = document.createElement("div");
      loadAnimationContainer.className = "load-animation";
    
      // Use the GIF instead of a lottie
      const gifImage = document.createElement("img");
      gifImage.src = "https://cdn.prod.website-files.com/64e508e8bea103fa08b8f130/6761f50a16ce8196496d4724_load-animation.gif";
      gifImage.alt = "Loading...";
      loadAnimationContainer.appendChild(gifImage);
    
      chatInnerWrapper.appendChild(loadAnimationContainer);
      chatBlock.appendChild(botAvatar);
      chatBlock.appendChild(chatInnerWrapper);
      chatBlockWrapper.appendChild(chatBlock);
      conversationWrapper.appendChild(chatBlockWrapper);
      conversationWrapper.scrollTop = conversationWrapper.scrollHeight;
    
      return { chatInnerWrapper, chatBlockWrapper };
    }
    
    async function handleSubmit() {
        stopVoiceTranscription(); // Existing voice transcription logic
        stopCurrentVoiceOutput(); // New logic to stop current voice output
    
        const message = textarea.value.trim();
        if (!message) return;
    
        console.log("User submitted message:", message);
    
        // Update Time-Last-Edited in Airtable if recordId exists
        if (airtableRecordId) {
            console.log("Updating Time-Last-Edited for record ID:", airtableRecordId);
            await updateTimeLastEdited(airtableRecordId);
        }
    
        createChatBlock(true, message); // Render user message
        resetHeight(); // Reset textarea height
    
        const { chatInnerWrapper, chatBlockWrapper } = createLoadingBlock(); // Show loading block
        const agentResponse = await startConversation(message); // Get AI response
        conversationWrapper.removeChild(chatBlockWrapper); // Remove loading block
        createChatBlock(false, agentResponse); // Render AI response

        finalSoFar = "";
        lastPartial = "";
    }


    
    // Attach event listeners
    textarea.addEventListener("input", adjustHeight);
    userSubmit.addEventListener("click", handleSubmit);
    
    textarea.addEventListener("keydown", (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key === "Enter") {
        e.preventDefault();
        handleSubmit();
      }
    });
    
    // Initialize speech recognition
    const recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
    recognition.continuous = true;
    recognition.interimResults = true;
    recognition.lang = "en-US";
    
    recognition.onresult = (event) => {
      // 1) Start with whatever is currently in the textarea
      let textSoFar = textarea.value;
    
      // We'll figure out how much new final text vs. partial text we got
      let newFinal = "";
      let newPartial = "";
    
      // 2) Loop through all the results from this speech event
      for (let i = event.resultIndex; i < event.results.length; i++) {
        if (event.results[i].isFinal) {
          newFinal += event.results[i][0].transcript;
        } else {
          newPartial += event.results[i][0].transcript;
        }
      }
    
      // 3) Remove the old partial from the end of textSoFar IF it matches exactly
      //    (If the user edited the text in that region, we skip this removal.)
      if (lastPartial && textSoFar.endsWith(lastPartial)) {
        textSoFar = textSoFar.slice(0, -lastPartial.length);
      }
    
      // 4) If we got new final text, append it. Then reset lastPartial.
      if (newFinal) {
        textSoFar += newFinal;
        finalSoFar += newFinal;   // If you need to keep a record of all final recognized text
        lastPartial = "";
      }
    
      // 5) If we also have new partial text, append it as ephemeral
      //    (This is the "live" text that might change on the next result.)
      if (newPartial) {
        textSoFar += newPartial;
        lastPartial = newPartial; // So we know what to remove next time
      }
    
      // 6) Update the textarea
      textarea.value = textSoFar;
    
      // 7) Adjust for auto-height
      adjustHeight();
    };


    
    recognition.onstart = () => {
      console.log("Speech recognition started.");
    };
    
    recognition.onend = () => {
      console.log("Speech recognition ended.");
      micButton.classList.remove("is-active");
      isListening = false;
    };
    
    recognition.onerror = (event) => {
      console.error("Speech recognition error:", event.error);
      micButton.classList.remove("is-active");
      isListening = false;
    };
    
    // Attach event listener to micButton
    if (micButton) {
      micButton.addEventListener("click", () => {
        console.log("Mic button clicked.");
        if (isListening) {
          recognition.stop();
          micButton.classList.remove("is-active");
          console.log("Stopped listening.");
        } else {
          recognition.start();
          micButton.classList.add("is-active");
          console.log("Started listening.");
        }
        isListening = !isListening;
      });
    } else {
      console.error("Cannot find #chat-user-input-mic element.");
    }
    
    // -----------------------------
    // Automatically Start Conversation
    // -----------------------------
    async function startInitialConversation() {
      // Clear existing chat blocks
      while (conversationWrapper.firstChild) {
        conversationWrapper.removeChild(conversationWrapper.firstChild);
      }
      console.log("Cleared existing chat blocks.");
    
      // Remove conversationID from the URL
      const url = new URL(window.location.href);
      url.searchParams.delete('conversationID');
      window.history.replaceState({}, '', url);
      console.log("Removed conversationID from URL.");
    
      // Reset the global conversationId variable
      conversationId = null;
      console.log("Reset conversationId to null.");
    
      // Create loading block
      const { chatInnerWrapper, chatBlockWrapper } = createLoadingBlock();
    
      // Construct the initial message
      const currentTime = new Date().toLocaleString();
      const initialMessage = `conversation_name=${currentTime}, current_username=${name}, current_user_email=${email}`;
      console.log("Sending initial message to AI:", initialMessage);
    
      // Send initial message to AI (not shown as user's message)
      const agentResponse = await startConversation(initialMessage);
    
      // Remove loading block
      conversationWrapper.removeChild(chatBlockWrapper);
    
      // Display only the AI's response
      createChatBlock(false, agentResponse);
    
      // Show the input UI so the user can continue
      if (chatInputWrapper) {
        chatInputWrapper.style.display = "grid";
        console.log("Input wrapper displayed as grid.");
      }
    }

    
    const startConversationButton = document.getElementById('start-new-conversation');
    if (startConversationButton) {
      startConversationButton.addEventListener('click', async (event) => {
        event.preventDefault();
        console.log('Starting a new conversation...');
    
        // Start a new conversation
        await startInitialConversation(); // Existing function to start the conversation
    
        // Collect metadata
        const container = document.getElementById('ai-agent-container');
        const userName = container.getAttribute('data-user-name') || 'Guest';
        const agentID = container.getAttribute('data-agent-id') || 'Unknown Agent';
        const timeStamp = new Date().toISOString(); // Current date/time in ISO format
    
        const metadata = {
          userName,
          agentID,
          conversationID: conversationId || 'Unknown Conversation ID',
          timeStamp,
          userId, // Include globally accessible User-ID
        };
    
        // Save to Airtable and set airtableRecordId
        if (userId) {
          const recordId = await saveConversationToAirtable(metadata);
          if (recordId) {
            airtableRecordId = recordId;
            console.log("New Airtable Record ID set after starting a new conversation:", airtableRecordId);
          }
        } else {
          console.log('User-ID is null. Skipping metadata save to Airtable.');
        }
      });
    } else {
      console.error("Button with id 'start-new-conversation' not found.");
    }

    let isVoiceOn = false; // Declare `isVoiceOn` globally
    
    document.addEventListener("click", (event) => {
        const voiceToggle = event.target.closest("#chat-voice-toggle");
        if (!voiceToggle) return;
    
        // Toggle the voice state
        isVoiceOn = !isVoiceOn;
        voiceToggle.classList.toggle("is-active", isVoiceOn);
        console.log(`Voice Output is now ${isVoiceOn ? "ON" : "OFF"}`);
    
        // If voice output is turned off, stop the current audio immediately
        if (!isVoiceOn && currentAudio) {
            currentAudio.pause(); // Stop playback
            currentAudio = null;  // Release the audio instance
            console.log("Voice output stopped immediately as toggle is OFF.");
        }
    });


    
    // Global variable to track the currently playing audio instance
    let currentAudio = null;
    
    // Function to handle text-to-speech with interruption management
    const playVoiceOutput = async (text) => {
        if (!isVoiceOn) return; // Do nothing if voice output is OFF
    
        const apiKey = "sk_065dc50b4b41b24e68999e7f5bbbd45e0dead586465ace18"; // Your API key
        const voiceId = "IKne3meq5aSn9XLyUdCD"; // Your voice ID
    
        try {
            // Stop any currently playing audio
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null; // Release the current audio instance
            }
    
            // Convert Markdown to plain text
            const plainText = markdownToPlainText(text);
    
            // Open a streaming connection to the ElevenLabs API
            const response = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${voiceId}/stream`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "xi-api-key": apiKey,
                },
                body: JSON.stringify({
                    text: plainText,
                    model_id: "eleven_flash_v2_5",
                }),
            });
    
            if (!response.ok) throw new Error("Failed to fetch audio stream");
    
            // Create a readable stream from the response body
            const reader = response.body.getReader();
            const audioChunks = [];
    
            let done = false;
            while (!done) {
                // Check if voice output is OFF during playback
                if (!isVoiceOn) {
                    console.log("Voice output interrupted; stopping playback.");
                    if (currentAudio) currentAudio.pause();
                    currentAudio = null; // Release audio instance
                    return; // Exit playback function
                }
    
                const { done: readerDone, value } = await reader.read();
                if (readerDone) {
                    done = true;
                    break;
                }
                audioChunks.push(value);
            }
    
            // Decode the audio chunks
            const audioData = new Blob(audioChunks);
            const arrayBuffer = await audioData.arrayBuffer();
            const audioContext = new AudioContext();
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
    
            // Create and configure the new audio instance
            const audio = new Audio();
            audio.src = URL.createObjectURL(audioData);
    
            // Track the current audio instance globally
            currentAudio = audio;
    
            // Play the audio
            audio.play();
    
            // Clean up when audio ends
            audio.onended = () => {
                currentAudio = null; // Release the instance
            };
        } catch (error) {
            console.error("Error during TTS playback:", error);
            currentAudio = null; // Ensure the instance is released on error
        }
    };

    
    // -----------------------------
    // Hook into the existing message rendering logic
    // -----------------------------
    const originalCreateChatBlock = createChatBlock; // Reference the existing function
    
    createChatBlock = (isUser, content) => {
        // Call the original function to preserve existing rendering
        originalCreateChatBlock(isUser, content);
    
        // Only scroll and speak if it's the AI (not the user)
        if (!isUser) {
            // 1) Scroll the conversation wrapper to the bottom
            conversationWrapper.scrollTop = conversationWrapper.scrollHeight;
            
            // 2) Play voice output for bot messages (existing functionality)
            playVoiceOutput(content);
        }
    };



  })();
</script>
