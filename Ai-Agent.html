<script type="text/javascript">!function(o,c){var n=c.documentElement,t=" w-mod-";n.className+=t+"js",("ontouchstart"in o||o.DocumentTouch&&c instanceof DocumentTouch)&&(n.className+=t+"touch")}(window,document);</script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/dompurify/dist/purify.min.js"></script>
<div class="page-wrapper is-app is-ami">
  <div class="main-wrapper">
    <div class="shell15_wrapper">
      <main class="shell15_main-wrapper">
        <div id="chat_conversation-wrapper" class="chat_conversation-wrapper"></div>
        <div class="chat_input-wrapper">

          <!-- New hamburger button (visible only on mobile) -->
          <div id="hamburger-menu-mobile" class="chat_input-button my-btn" data-tooltip="Open Menu">
            <div class="icon-embed-small w-embed">
            </div>
          </div>
          <!-- End new hamburger button -->

          <div id="chat-file-input" class="chat_input-button my-btn" data-tooltip="Attach a file for the agent">
            <!-- File upload icon -->
            <div id="chat-file-input-icon" class="icon-embed-small w-embed">
              <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--ic" width="100%" height="100%" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24">
                <path fill="currentColor" d="M16.5 6v11.5c0 2.21-1.79 4-4 4s-4-1.79-4-4V5a2.5 2.5 0 0 1 5 0v10.5c0 .55-.45 1-1 1s-1-.45-1-1V6H10v9.5a2.5 2.5 0 0 0 5 0V5c0-2.21-1.79-4-4-4S7 2.79 7 5v12.5c0 3.04 2.46 5.5 5.5 5.5s5.5-2.46 5.5-5.5V6z"></path>
              </svg>
            </div>
            <!-- Loading animation GIF -->
            <img id="chat-file-loading" src="https://member.archmarketing.org/wp-content/uploads/2025/01/ZKZg.gif" alt="Loading..." style="display: none; width: 24px; height: 24px;">
          </div>
          <div id="chat-user-input-mic" class="chat_input-button w-node-d52fb02a-d5b0-6fa8-115b-d486e3e4b322-8f158f72 my-btn" data-tooltip="Speak to the agent">
            <div class="icon-embed-small w-embed">
              <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--ic" width="100%" height="100%" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24">
                <path fill="currentColor" d="M12 15c1.66 0 2.99-1.34 2.99-3L15 6c0-1.66-1.34-3-3-3S9 4.34 9 6v6c0 1.66 1.34 3 3 3m-1.2-9.1c0-.66.54-1.2 1.2-1.2s1.2.54 1.2 1.2l-.01 6.2c0 .66-.53 1.2-1.19 1.2s-1.2-.54-1.2-1.2zm6.5 6.1c0 3-2.54 5.1-5.3 5.1S6.7 15 6.7 12H5c0 3.41 2.72 6.23 6 6.72V22h2v-3.28c3.28-.48 6-3.3 6-6.72z"></path>
              </svg>
            </div>
          </div>
          <div id="chat-voice-toggle" class="chat_input-button my-btn" data-tooltip="Toggle agent voice output">
            <div class="icon-embed-small w-embed">
              <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--bx" width="32" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24">
                <path fill="currentColor" d="M8 12c2.28 0 4-1.72 4-4s-1.72-4-4-4s-4 1.72-4 4s1.72 4 4 4m0-6c1.178 0 2 .822 2 2s-.822 2-2 2s-2-.822-2-2s.822-2 2-2m1 7H7c-2.757 0-5 2.243-5 5v1h2v-1c0-1.654 1.346-3 3-3h2c1.654 0 3 1.346 3 3v1h2v-1c0-2.757-2.243-5-5-5m9.364-10.364L16.95 4.05C18.271 5.373 19 7.131 19 9s-.729 3.627-2.05 4.95l1.414 1.414C20.064 13.663 21 11.403 21 9s-.936-4.663-2.636-6.364"></path>
                <path fill="currentColor" d="M15.535 5.464L14.121 6.88C14.688 7.445 15 8.198 15 9s-.312 1.555-.879 2.12l1.414 1.416C16.479 11.592 17 10.337 17 9s-.521-2.592-1.465-3.536"></path>
              </svg>
            </div>
          </div>
          <div id="chat-canvas-toggle"
               class="chat_input-button my-btn"
               data-tooltip="Open the canvas">
            <div class="icon-embed-small w-embed">
              <!-- BEGIN OpenAI-style pencil-plus SVG -->
              <svg width="28" height="28" viewBox="0 0 24 24" fill="none"
                   xmlns="http://www.w3.org/2000/svg">
                <path d="M2.5 5.5C4.3 5.2 5.2 4 5.5 2.5C5.8 4 6.7 5.2 8.5 5.5C6.7 5.8 5.8 7 5.5 8.5C5.2 7 4.3 5.8 2.5 5.5Z"
                      fill="currentColor" stroke="currentColor"
                      stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M5.66282 16.5231L5.18413 19.3952C5.12203 19.7678 5.09098 19.9541 5.14876 20.0888C5.19933 20.2067 5.29328 20.3007 5.41118 20.3512C5.54589 20.409 5.73218 20.378 6.10476 20.3159L8.97693 19.8372C9.72813 19.712 10.1037 19.6494 10.4542 19.521C10.7652 19.407 11.0608 19.2549 11.3343 19.068C11.6425 18.8575 11.9118 18.5882 12.4503 18.0497L20 10.5C21.3807 9.11929 21.3807 6.88071 20 5.5C18.6193 4.11929 16.3807 4.11929 15 5.5L7.45026 13.0497C6.91175 13.5882 6.6425 13.8575 6.43197 14.1657C6.24513 14.4392 6.09299 14.7348 5.97903 15.0458C5.85062 15.3963 5.78802 15.7719 5.66282 16.5231Z"
                      stroke="currentColor" stroke-width="2"
                      stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M14.5 7L18.5 11"
                      stroke="currentColor" stroke-width="2"
                      stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </div>
          </div>
          <div id="w-node-_819b1fcb-bef5-c69d-b33b-f104bd5e9695-8f158f72" class="chat_input-text">
            <div id="w-node-_256faa1f-1943-6b85-6f8e-bd7a8a4af011-8f158f72" class="code-embed-2 w-embed">
              <div class="form-input is-app">
                <textarea id="chat-user-input" class="textarea-dynamic" rows="1" placeholder="Type your response here..."></textarea>
              </div>
            </div>
          </div>
          <div id="chat-user-submit" class="button is-app w-node-_4bf83d64-1477-4e83-8a98-23560ff07d2d-8f158f72 w-inline-block my-btn" draggable="false" data-tooltip="Send your message">
            <div class="chat_submit-input w-embed">
              <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--heroicons" width="100%" height="100%" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24">
                <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M6 12L3.269 3.125A59.8 59.8 0 0 1 21.486 12a59.8 59.8 0 0 1-18.217 8.875zm0 0h7.5"></path>
              </svg>
            </div>
          </div>
        </div>
      </main>
    </div>
  </div>
</div>




<!-- Reusable tooltip container (initially hidden) -->
<div id="global-tooltip" class="tooltip-hidden"></div>


<!-- Existing HTML structure remains unchanged -->

<script type="module">
import { createClient, LiveTranscriptionEvents } from "https://cdn.jsdelivr.net/npm/@deepgram/sdk/+esm";
const API_KEY = "9dcf3c4e022285b7ea553a57c663cb66bbd5c68e";
const deepgram = createClient(API_KEY);
window.deepgram = deepgram;
window.LiveTranscriptionEvents = LiveTranscriptionEvents;
  
  (function() {
    console.log("Chatbot initialized.");

    // 1) Get the container in which this HTML was injected
    const container = document.getElementById("ai-agent-container");
    
    // 2) Read data attributes (fallback to defaults if missing)
    const agentId  = container?.getAttribute("data-agent-id") || "6a12b1cd-b7d5-4b00-80ee-d2829af810dc";
    const name     = container?.getAttribute("data-user-name") || "Guest";
    const email    = container?.getAttribute("data-user-email") || "noemail@domain.com";
    const agentInfo = container?.getAttribute("data-agent-info") || "";  // New attribute

    
    // Configuration for AI agent
    const region = "bcbe5a"; // Replace with your region
    const projectId = "c5bf489c1af9-4886-afba-073965a5ad71"; // Replace with your project ID
    const apiKey = "sk-MGJlOWM0NGEtMjgyNC00MTIwLTg5NGUtN2IwMzljMmNjNDgx"; // Replace with your API key
    
    // Use base64 encoding for the authorization token
    const authorizationToken = `Basic ${btoa(`${projectId}:${apiKey}`)}`;
    const baseUrl = `https://api-${region}.stack.tryrelevance.com/latest`;
    const headers = {
      Authorization: authorizationToken,
      "Content-Type": "application/json",
    };
    
    // DOM elements
    const textarea = document.getElementById("chat-user-input");
    const BASE_TEXTAREA_HEIGHT = 38; // Base height in pixels for the textarea
    
    const userSubmit = document.getElementById("chat-user-submit");
    const conversationWrapper = document.getElementById("chat_conversation-wrapper");
    let chatSpacer = document.getElementById("chat-spacer");
    if (!chatSpacer) {
      chatSpacer = document.createElement("div");
      chatSpacer.id = "chat-spacer";
      chatSpacer.style.height = "0px"; // Start with zero height
      // Append the spacer at the end of the conversation container
      conversationWrapper.appendChild(chatSpacer);
    }

    const chatInputWrapper = document.querySelector(".chat_input-wrapper");

    const urlParams = new URLSearchParams(window.location.search);
    const conversationID = urlParams.get('conversationID');

    let airtableRecordId = null;

    let isBusy = false; // NEW: Blocks user while AI is responding
    let conversationUserAvatar = null;

    // --- Begin Deepgram Transcription Integration ---
    let dgConnection;
    let mediaStream;
    let audioContext;
    let processor;
    let keepAliveInterval;
    let isDeepgramListening = false;
    let finalTranscript = "";
    let lastInterim = "";

    let isMicOn = false;     // For controlling Deepgram mic usage (STT)
    let isVoiceOn = false;   // For controlling ElevenLabs voice output (TTS)

    window.airtableRecordId = null;

    // Helper: Convert Float32Array to 16-bit PCM ArrayBuffer
    function floatTo16BitPCM(input) {
      const output = new Int16Array(input.length);
      for (let i = 0; i < input.length; i++) {
        let s = Math.max(-1, Math.min(1, input[i]));
        output[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
      }
      return output.buffer;
    }
    
    // Function to start Deepgram transcription
    async function startDeepgramTranscription() {
      try {
        // Request microphone access (HTTPS required)
        mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        console.log("Microphone access granted");
        
        // Create an AudioContext with a sample rate of 16000 Hz
        audioContext = new AudioContext({ sampleRate: 16000 });
        console.log("AudioContext sampleRate:", audioContext.sampleRate);
        const source = audioContext.createMediaStreamSource(mediaStream);
        
        // Use a ScriptProcessorNode with a buffer size of 2048 for broad device compatibility
        processor = audioContext.createScriptProcessor(2048, 1, 1);
        source.connect(processor);
        processor.connect(audioContext.destination);
        
        // Initialize Deepgram live transcription connection with explicit audio format and interim results enabled
        dgConnection = deepgram.listen.live({
          model: "nova-3",
          language: "en-US",
          smart_format: true,
          encoding: "linear16",
          channels: 1,
          sample_rate: 16000,
          interim_results: true,
        });
        
        dgConnection.on(LiveTranscriptionEvents.Open, () => {
          console.log("Deepgram connection opened");
          // Start keep-alive messages every 3 seconds
          keepAliveInterval = setInterval(() => {
            if (dgConnection.getReadyState() === WebSocket.OPEN) {
              dgConnection.keepAlive();
              console.log("KeepAlive sent");
            }
          }, 3000);
        });
        
        dgConnection.on(LiveTranscriptionEvents.Transcript, (data) => {
          // 1) Grab the actual transcript and check if it's final or partial
          let transcript = data.channel?.alternatives?.[0]?.transcript || "";
          const isFinal = data.is_final;
        
          // 2) If the chunk is empty or just whitespace, skip it
          if (transcript.trim().length === 0) {
            console.log("Blank chunk detected. Not appending anything.");
            return;
          }
        
          // 3) Start with whatever is currently in the textarea
          let textSoFar = textarea.value;
        
          // 4) If we previously appended `lastInterim` at the end, remove it
          if (lastInterim && textSoFar.endsWith(lastInterim)) {
            textSoFar = textSoFar.slice(0, -lastInterim.length);
          }
        
          // 5) Append differently based on final vs. partial transcript
          if (isFinal) {
            // If final, permanently add it to the text + finalTranscript
            textSoFar += transcript + " ";
            finalTranscript += transcript + " ";
            lastInterim = "";
          } else {
            // If partial, store in lastInterim + append it at the end
            lastInterim = transcript;
            textSoFar += transcript;
          }
        
          // 6) Update the textarea with the new text
          textarea.value = textSoFar;
        
          // 7) Dynamically resize now that we’ve changed the value
          adjustHeight();
        
          // Debug log
          console.log("Transcript updated:", textSoFar);
        });


        dgConnection.on(LiveTranscriptionEvents.Error, (err) => {
          console.error("Deepgram error:", err);
        });
        
        dgConnection.on(LiveTranscriptionEvents.Close, () => {
          console.log("Deepgram connection closed");
        });
        
        // Process audio frames and send them to Deepgram as 16-bit PCM
        processor.onaudioprocess = (event) => {
          const inputData = event.inputBuffer.getChannelData(0);
          const pcmData = floatTo16BitPCM(inputData);
          if (dgConnection.getReadyState() === WebSocket.OPEN) {
            dgConnection.send(pcmData);
          }
        };
        
        isDeepgramListening = true;
        console.log("Deepgram transcription started");
      } catch (error) {
        console.error("Error starting Deepgram transcription:", error);
      }
    }
    
    // Function to stop Deepgram transcription and clean up resources
    function stopDeepgramTranscription() {
      if (keepAliveInterval) clearInterval(keepAliveInterval);
      if (processor) {
        processor.disconnect();
        processor.onaudioprocess = null;
      }
      if (audioContext) {
        audioContext.close();
      }
      if (mediaStream) {
        mediaStream.getTracks().forEach(track => track.stop());
      }
      if (dgConnection && dgConnection.getReadyState() === WebSocket.OPEN) {
        dgConnection.requestClose();
      }
      isDeepgramListening = false;
      console.log("Deepgram transcription stopped");
    }
    
    const micButton = document.getElementById("chat-user-input-mic");
    if (micButton) {
      micButton.addEventListener("click", () => {
        console.log("Mic button clicked.");
        if (!isMicOn) {
          // Start Deepgram transcription
          startDeepgramTranscription();
          micButton.classList.add("is-active");
          console.log("Started Deepgram transcription.");
        } else {
          // Stop Deepgram transcription
          stopDeepgramTranscription();
          micButton.classList.remove("is-active");
          console.log("Stopped Deepgram transcription.");
        }
        isMicOn = !isMicOn;
      });
    } else {
      console.error("Cannot find mic button with id 'chat-user-input-mic'.");
    }




    // Helper function to extract an alternate firm ID from the "agent-info" query parameter
    function getAlternateUserIdFromUrl() {
      const urlParams = new URLSearchParams(window.location.search);
      let agentInfo = urlParams.get("agent-info");
      if (!agentInfo) return null;
      
      // Expected prefix after one decoding
      const expectedPrefix = "firmID%253D%";
      
      // If the current value does not start with the expected prefix,
      // try to decode it again
      if (!agentInfo.startsWith(expectedPrefix)) {
        try {
          agentInfo = decodeURIComponent(agentInfo);
        } catch (e) {
          console.error("Error decoding agent-info:", e);
        }
      }
      
      if (agentInfo.startsWith(expectedPrefix)) {
        return agentInfo.substring(expectedPrefix.length);
      }
      return null;
    }



    
    function updateConversationUserAvatarStyle(imageUrl) {
      let styleEl = document.getElementById("conversation-user-avatar-style");
      if (!styleEl) {
        styleEl = document.createElement("style");
        styleEl.id = "conversation-user-avatar-style";
        document.head.appendChild(styleEl);
      }
      styleEl.textContent = `
        .chat_user-avatar.conversation-user-avatar {
          background-image: url("${imageUrl}") !important;
          background-size: cover !important;
          background-position: center !important;
          background-repeat: no-repeat !important;
        }
      `;
    }



    /*********************************************************
     *  MOBILE SIDEBAR DRAWER LOGIC (Hamburger ⇄ X icon)
     *********************************************************/
    
    /* 1) Two icon constants (Hamburger & Close) */
    const HAMBURGER_SVG = `
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" width="100%" height="100%" viewBox="0 0 24 24">
      <path fill="currentColor" d="M3 6h18v2H3V6zm0 5h18v2H3v-2zm0 5h18v2H3v-2z"></path>
    </svg>
    `;
    
    const CLOSE_SVG = `
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" width="100%" height="100%" viewBox="0 0 24 24">
      <path fill="currentColor" d="M18.3 5.71a1 1 0 0 0-1.41 0L12 10.59 
      7.11 5.7a1 1 0 0 0-1.42 1.41L10.59 12l-4.9 4.88a1 1 0 1 0 1.41 1.42L12 13.41 
      16.88 18.3a1 1 0 0 0 1.42-1.41L13.41 12l4.88-4.88a1 1 0 0 0 0-1.41Z"/>
    </svg>
    `;
    
    /* 2) Grab references to your hamburger + sidebar */
    const hamburgerMenu = document.getElementById("hamburger-menu-mobile");
    const sidebar = document.querySelector(".sAsCont");
    
    /* We'll also find the .icon-embed-small inside the hamburger */
    let hamburgerIconContainer = null;
    if (hamburgerMenu) {
      hamburgerIconContainer = hamburgerMenu.querySelector('.icon-embed-small');
    }
    
    /**
     * 3) Toggle function
     *    - Toggles .mobile-drawer-open
     *    - Swaps icon (hamburger ⇄ close) 
     */
    function toggleSidebarOnMobile() {
      // Only if screen width <= 939 AND we have valid elements
      if (window.innerWidth <= 939 && sidebar && hamburgerIconContainer) {
        const isOpenNow = sidebar.classList.contains('mobile-drawer-open');
        
        // Toggle the class
        sidebar.classList.toggle('mobile-drawer-open');
        
        // If was open, show hamburger (closing it),
        // If was closed, show X (opening it)
        if (isOpenNow) {
          hamburgerIconContainer.innerHTML = HAMBURGER_SVG;
        } else {
          hamburgerIconContainer.innerHTML = CLOSE_SVG;
        }
      }
    }
    
    /* 4) Default icon = hamburger lines (closed state) */
    if (hamburgerIconContainer) {
      hamburgerIconContainer.innerHTML = HAMBURGER_SVG;
    }
    
    /* 5) Attach the click event to the hamburger menu */
    if (hamburgerMenu && sidebar) {
      hamburgerMenu.addEventListener("click", toggleSidebarOnMobile);
    } else {
      console.warn("Hamburger menu or .sAsCont sidebar not found in DOM.");
    }


    function showChatInputWrapper() {
      const isMobile = window.innerWidth <= 940;
      if (!chatInputWrapper) {
        console.warn("chatInputWrapper not found. Cannot show the input wrapper.");
        return;
      }
      // Use flex on mobile; grid on desktop
      chatInputWrapper.style.display = isMobile ? "flex" : "grid";
    }


    function markdownToPlainText(markdown) {
      // 1) Parse to HTML
      const html = marked.parse(markdown);
    
      // 2) Sanitize
      const sanitizedHtml = DOMPurify.sanitize(html);
    
      // 3) Put it in a temporary <div> to extract text
      const tmpDiv = document.createElement('div');
      tmpDiv.innerHTML = sanitizedHtml;
    
      // 4) Return the plain text (this preserves line breaks)
      return tmpDiv.innerText || '';
    }

    function replacePreCodeWithMarkdown(parentElement) {
      // STEP 1: Define your icons (copy + check)
      const COPY_ICON_SVG = `
        <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
             role="img" width="16" height="16" viewBox="0 0 24 24">
          <path fill="currentColor"
                d="M15 20H5V7c0-.55-.45-1-1-1s-1
                   .45-1 1v13c0 1.1.9 2 2 
                   2h10c.55 0 1-.45 
                   1-1s-.45-1-1-1m5-4V4
                   c0-1.1-.9-2-2-2H9c-1.1 
                   0-2 .9-2 2v12c0 1.1.9 
                   2 2 2h9c1.1 
                   0 2-.9 2-2m-2 
                   0H9V4h9z">
          </path>
        </svg>
      `;
    
      const CHECK_ICON_SVG = `
        <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
             role="img" width="16" height="16" viewBox="0 0 24 24">
          <path fill="currentColor"
                d="M20.29 5.71a1 1 0 
                   0 0-1.42 0L10 14.59l-4.29-4.3
                   a1 1 0 0 0-1.42 
                   1.42l5 5a1 1 0 0 
                   0 1.42 0l10-10a1 
                   1 0 0 0 0-1.42Z">
          </path>
        </svg>
      `;
    
      const codeBlocks = parentElement.querySelectorAll('pre code');
    
      codeBlocks.forEach((codeBlock) => {
        // 1) Grab the raw text inside <code>
        const rawText = codeBlock.textContent || '';
    
        // 2) Render it as normal Markdown HTML for DISPLAY
        const renderedHtml = marked.parse(rawText);
        const sanitizedHtml = DOMPurify.sanitize(renderedHtml);
    
        // 3) Create a container <div> for that rendered content
        const mdContainer = document.createElement('div');
        mdContainer.classList.add('md-block-container');
        mdContainer.innerHTML = sanitizedHtml;
    
        // 4) Convert rawText to plain text (if you want no markdown in the copied text)
        const plainText = markdownToPlainText(rawText);
    
        // 5) Create a "Copy" button with icon + text
        const copyBtn = document.createElement('button');
        copyBtn.classList.add('md-copy-btn');
        copyBtn.innerHTML = `
          <span class="icon-container">${COPY_ICON_SVG}</span>
          <span class="button-text">Copy</span>
        `;
        
        // 6) On click, copy plainText to clipboard
        copyBtn.addEventListener('click', () => {
          navigator.clipboard.writeText(plainText)
            .then(() => {
              // Swap to tick icon + "Copied!"
              copyBtn.innerHTML = `
                <span class="icon-container">${CHECK_ICON_SVG}</span>
                <span class="button-text">Copied!</span>
              `;
              setTimeout(() => {
                copyBtn.innerHTML = `
                  <span class="icon-container">${COPY_ICON_SVG}</span>
                  <span class="button-text">Copy</span>
                `;
              }, 2000);
            })
            .catch((err) => {
              console.error('Clipboard copy failed:', err);
            });
        });
    
        // 7) Optionally wrap the button in a small header
        const headerDiv = document.createElement('div');
        headerDiv.classList.add('md-header');
        headerDiv.appendChild(copyBtn);
    
        mdContainer.insertBefore(headerDiv, mdContainer.firstChild);
    
        // 8) Replace the entire <pre> with mdContainer
        const preEl = codeBlock.closest('pre');
        if (preEl?.parentNode) {
          preEl.parentNode.replaceChild(mdContainer, preEl);
        }
      });
    }


    function handleFileUpload() {
      // Create a hidden file input element
      const fileInput = document.createElement("input");
      fileInput.type = "file";
      fileInput.accept = "*/*"; // Accept ANY file type
      fileInput.style.display = "none";
  
      // DOM elements for toggling visibility
      const fileIcon = document.getElementById("chat-file-input-icon");
      const loadingGif = document.getElementById("chat-file-loading");
      const userInput = document.getElementById("chat-user-input");
  
      fileInput.addEventListener("change", async (event) => {
        const file = event.target.files[0];
        if (!file) return;
  
        fileIcon.style.display = "none";
        loadingGif.style.display = "block";
  
        // Adjusted Cloudinary endpoint with your actual cloud name
        let uploadUrl = "https://api.cloudinary.com/v1_1/dgt84jatm";
        let fileLabel = "";
  
        try {
          if (file.type.startsWith("image/")) {
            uploadUrl += "/image/upload";
            fileLabel = "Image";
          } else if (file.type.startsWith("audio/") || file.type.startsWith("video/")) {
            uploadUrl += "/video/upload";
            fileLabel = file.type.startsWith("audio/") ? "Audio" : "Video";
          } else {
            uploadUrl += "/raw/upload";
            fileLabel = "File";
          }
  
          const formData = new FormData();
          formData.append("file", file);
          formData.append("upload_preset", "my_unsigned_preset"); // Replace with your preset if needed
  
          const response = await fetch(uploadUrl, {
            method: "POST",
            body: formData,
          });
  
          if (!response.ok) {
            throw new Error("Failed to upload the file to Cloudinary");
          }
  
          const data = await response.json();
          const hostedUrl = data.secure_url;
          const formattedOutput = `(${fileLabel}: ${hostedUrl})`;
  
          userInput.value += ` ${formattedOutput}`;
          adjustHeight(); // Already defined in your code
  
        } catch (error) {
          console.error("Error uploading file:", error);
          alert("There was an issue uploading your file. Please try again.");
        } finally {
          fileIcon.style.display = "block";
          loadingGif.style.display = "none";
        }
      });
  
      fileInput.click();
    }


  const chatFileInputButton = document.getElementById("chat-file-input");
  if (chatFileInputButton) {
    chatFileInputButton.addEventListener("click", handleFileUpload);
  }


    function stopCurrentVoiceOutput() {
        if (currentAudio) {
            currentAudio.pause(); // Stop playback
            currentAudio = null;  // Release the audio instance
            console.log("Current voice output stopped.");
        }
    }


    // Utility function to convert Markdown to plain text
    function markdownToPlainText(markdown) {
        // Ensure the `marked` object is correctly accessed
        const parser = typeof marked === "function" ? marked : marked.parse;
    
        // Parse Markdown to HTML
        const html = parser(markdown);
    
        // Sanitize the HTML
        const sanitizedHtml = DOMPurify.sanitize(html);
    
        // Create a temporary DOM element to extract plain text
        const tempDiv = document.createElement("div");
        tempDiv.innerHTML = sanitizedHtml;
    
        // Return plain text content
        return tempDiv.textContent || tempDiv.innerText || "";
    }



    if (conversationID) {
      console.log("Conversation ID found in URL:", conversationID);
      fetchAirtableRecordId(conversationID).then(() => {
        console.log("Airtable Record ID set from existing conversation ID:", airtableRecordId);
      });
    } else {
      console.log("No conversation ID provided in the URL. Waiting for user to start a new conversation.");
    }



    async function fetchAirtableRecordId(conversationID) {
      const airtableBaseUrl = 'https://api.airtable.com/v0/app2N6x5jeRnIzSpL/Conversations';
      const airtableHeaders = {
        Authorization: 'Bearer patTeuxUuzgG0ZU8Q.2eb9ff7f31afe3e06f3c128c5b5b832bcc4e4e85bd58a5007a8368f218d28b83',
        'Content-Type': 'application/json',
      };
    
      try {
        const response = await fetch(`${airtableBaseUrl}?filterByFormula={Conversation-ID}="${conversationID}"`, {
          method: 'GET',
          headers: airtableHeaders,
        });
    
        if (response.ok) {
          const data = await response.json();
          if (data.records && data.records.length > 0) {
            const record = data.records[0];
            airtableRecordId = record.id; // Save the record ID
            console.log("Fetched Airtable Record ID:", airtableRecordId);
    
            // Retrieve and log the Email from the conversation record.
            const conversationEmail = record.fields['Email'];
            if (conversationEmail) {
              console.log("Conversation email:", conversationEmail);
              const encodedEmail = encodeURIComponent(conversationEmail);
              // Query the Users table using the encoded email.
              const userProfileImage = await fetchUserProfileImageByEmail(encodedEmail);
              console.log("User profile image from conversation email:", userProfileImage);
              // Store the image URL globally for rendering previous messages.
              conversationUserAvatar = userProfileImage;
              // Inject the CSS rule to override avatars in previous messages.
              if (userProfileImage) {
                updateConversationUserAvatarStyle(userProfileImage);
              }
            } else {
              console.log("No Email field found in the conversation record.");
            }
          } else {
            console.log("No matching Airtable record found for Conversation-ID:", conversationID);
          }
        } else {
          console.error("Error fetching Airtable record ID:", await response.text());
        }
      } catch (error) {
        console.error("Error during Airtable record ID fetch:", error);
      }
    }

    // --- NEW: Function to fetch conversation metadata from Airtable ---
    async function fetchConversationMetadata(conversationID) {
      const airtableBaseUrl = 'https://api.airtable.com/v0/app2N6x5jeRnIzSpL/Conversations';
      const airtableHeaders = {
        Authorization: 'Bearer patTeuxUuzgG0ZU8Q.2eb9ff7f31afe3e06f3c128c5b5b832bcc4e4e85bd58a5007a8368f218d28b83',
        'Content-Type': 'application/json',
      };
      try {
        const response = await fetch(`${airtableBaseUrl}?filterByFormula={Conversation-ID}="${conversationID}"`, {
          method: 'GET',
          headers: airtableHeaders,
        });
        if (response.ok) {
          const data = await response.json();
          if (data.records && data.records.length > 0) {
            const record = data.records[0];
            // Retrieve the desired fields
            const clientName = record.fields['Client-Name'] || 'Unknown';
            const timeLastEdited = record.fields['Time-Last-Edited'] || 'Unknown';
            const summary = record.fields['Summary'] || '';
            return { clientName, timeLastEdited, summary };
          } else {
            console.error("No matching Airtable record found for Conversation-ID:", conversationID);
            return null;
          }
        } else {
          console.error("Error fetching conversation metadata:", await response.text());
          return null;
        }
      } catch (error) {
        console.error("Error during fetchConversationMetadata:", error);
        return null;
      }
    }



    async function updateTimeLastEdited(recordId) {
      const airtableBaseUrl = 'https://api.airtable.com/v0/app2N6x5jeRnIzSpL/Conversations';
      const airtableHeaders = {
        Authorization: 'Bearer patTeuxUuzgG0ZU8Q.2eb9ff7f31afe3e06f3c128c5b5b832bcc4e4e85bd58a5007a8368f218d28b83',
        'Content-Type': 'application/json',
      };
    
      try {
        const response = await fetch(`${airtableBaseUrl}/${recordId}`, {
          method: 'PATCH',
          headers: airtableHeaders,
          body: JSON.stringify({
            fields: {
              'Time-Last-Edited': new Date().toISOString(), // Current time in GMT
            },
          }),
        });
    
        if (response.ok) {
          console.log("Successfully updated Time-Last-Edited:", await response.json());
        } else {
          console.error("Error updating Time-Last-Edited:", await response.text());
        }
      } catch (error) {
        console.error("Error during PATCH request:", error);
      }
    }


    // Function to fetch profile image from Airtable
    async function fetchAgentProfileImage(agentId) {
      const airtableBaseUrl = 'https://api.airtable.com/v0/app2N6x5jeRnIzSpL/Agents';
      const airtableHeaders = {
        Authorization: 'Bearer patTeuxUuzgG0ZU8Q.2eb9ff7f31afe3e06f3c128c5b5b832bcc4e4e85bd58a5007a8368f218d28b83',
        'Content-Type': 'application/json',
      };
    
      try {
        const response = await fetch(`${airtableBaseUrl}?filterByFormula={Agent-ID}="${agentId}"`, {
          method: 'GET',
          headers: airtableHeaders,
        });
    
        if (response.ok) {
          const data = await response.json();
          if (data.records && data.records.length > 0) {
            const record = data.records[0];
            // Safely access fields
            const profileImage = record.fields['Profile-Image']?.[0]?.url || null;
            const voiceId = record.fields['Voice-ID'] || null;
    
            console.log("Profile Image URL:", profileImage);
            console.log("Voice ID:", voiceId);
    
            // Return both as an object
            return { profileImage, voiceId };
          } else {
            console.log("No record found for Agent-ID:", agentId);
            return { profileImage: null, voiceId: null };
          }
        } else {
          console.error("Failed to fetch data from Airtable:", await response.text());
          return { profileImage: null, voiceId: null };
        }
      } catch (error) {
        console.error("Error fetching data from Airtable:", error);
        return { profileImage: null, voiceId: null };
      }
    }
    
    function updateChatBotAvatarStyle(profileImage) {
      if (profileImage) {
        const style = document.createElement('style');
        style.textContent = `
          .chat_bot-avatar {
            background-image: url("${profileImage}") !important;
            background-size: cover !important;
            background-position: center !important;
            background-repeat: no-repeat !important;
          }
        `;
        document.head.appendChild(style);
        console.log("Updated chat_bot-avatar style globally with !important.");
      } else {
        console.log("No profile image provided, skipping style update.");
      }
    }

    
    (async function initializeChatBot() {
      const agentId = container?.getAttribute("data-agent-id") || "6a12b1cd-b7d5-4b00-80ee-d2829af810dc";
  
      // Destructure both profileImage and voiceId from the function
      const { profileImage, voiceId } = await fetchAgentProfileImage(agentId);
  
      // Update the chatbot avatar style
      updateChatBotAvatarStyle(profileImage);
  
      // Store the fetched Voice-ID in a global variable for TTS
      window.__agentVoiceId = voiceId;
    })();


    async function fetchUserProfileImageByEmail(encodedEmail) {
      try {
        const airtableBaseUrl = 'https://api.airtable.com/v0/app2N6x5jeRnIzSpL/Users';
        const airtableHeaders = {
          Authorization: 'Bearer patTeuxUuzgG0ZU8Q.2eb9ff7f31afe3e06f3c128c5b5b832bcc4e4e85bd58a5007a8368f218d28b83',
          'Content-Type': 'application/json',
        };
    
        // Build the filter formula using the plain email (decoded) then encode the entire string.
        const filterFormula = encodeURIComponent(`{Email}="${decodeURIComponent(encodedEmail)}"`);
        const response = await fetch(`${airtableBaseUrl}?filterByFormula=${filterFormula}`, {
          method: 'GET',
          headers: airtableHeaders,
        });
    
        if (response.ok) {
          const data = await response.json();
          if (data.records && data.records.length > 0) {
            const profileImage = data.records[0].fields['Profile-Image']?.[0]?.url;
            console.log("User Profile Image URL:", profileImage);
            return profileImage;
          } else {
            console.log("No user record found for Email:", decodeURIComponent(encodedEmail));
            return null;
          }
        } else {
          console.error("Failed to fetch data from Airtable:", await response.text());
          return null;
        }
      } catch (error) {
        console.error("Error fetching user profile image from Airtable:", error);
        return null;
      }
    }

    
    // Function to update the global style for chat_user-avatar
    function updateChatUserAvatarStyle(profileImage) {
      if (profileImage) {
        const style = document.createElement('style');
        style.textContent = `
          .chat_user-avatar {
            background-image: url("${profileImage}") !important;
            background-size: cover !important;
            background-position: center !important;
            background-repeat: no-repeat !important;
          }
        `;
        document.head.appendChild(style);
        console.log("Updated chat_user-avatar style globally with !important.");
      } else {
        console.log("No user profile image provided, skipping style update.");
      }
    }

    function renderConversationHeader({ clientName, timeLastEdited, summary }) {
      // Create a header container element
      const headerContainer = document.createElement('div');
      headerContainer.className = 'conversation-header';
      headerContainer.style.padding = '10px';
      headerContainer.style.marginBottom = '10px';
      headerContainer.style.fontFamily = 'Arial, sans-serif';
      headerContainer.style.color = '#b1b1b1'; // Overall text color
      headerContainer.style.fontSize = '14px'; // Overall font size
    
      // Helper function to create a labeled line using <span>
      function createHeaderLine(label, value) {
        const lineEl = document.createElement('div');
        lineEl.className = 'conversation-header-item';
    
        // Use <span> with "all: revert !important" to undo external styles,
        // then apply our own color/weight with !important to override everything else.
        lineEl.innerHTML = `
          <span 
            style="
              all: revert !important;
              font-weight: 700 !important;
              color: #b1b1b1 !important;
            "
          >
            ${label}
          </span>
          <span style="margin-left: 5px;">${value}</span>
        `;
        return lineEl;
      }
    
      // 1) Conversation Started By
      const startedByEl = createHeaderLine('Conversation Started By:', clientName);
      headerContainer.appendChild(startedByEl);
    
      // 2) Date & Time Last Edited
      const lastEditedEl = createHeaderLine('Date & Time Last Edited:', timeLastEdited);
      headerContainer.appendChild(lastEditedEl);
    
      // 3) Conversation Summary (if present)
      if (summary) {
        const summaryEl = createHeaderLine('Conversation Summary:', summary);
        headerContainer.appendChild(summaryEl);
      }
    
      // Insert the headerContainer at the top of the conversation wrapper
      const conversationWrapper = document.getElementById("chat_conversation-wrapper");
      if (conversationWrapper) {
        // Remove any existing header to prevent duplicates
        const existingHeader = conversationWrapper.querySelector('.conversation-header');
        if (existingHeader) {
          conversationWrapper.removeChild(existingHeader);
        }
        conversationWrapper.insertBefore(headerContainer, conversationWrapper.firstChild);
      }
    }



    
    // Initialize the process for user profile image
    (async function initializeUserAvatar() {
      const userProfileImage = await fetchUserProfileImageByEmail(email); // Use the email variable defined in the code
      updateChatUserAvatarStyle(userProfileImage);
    })();

    /* ──────────────────────────────────────────────────────────────
     * GUARANTEED Airtable upsert  →  creates OR patches one row
     * Call this every time you have/receive conversationID.
     * ────────────────────────────────────────────────────────────*/
    async function ensureAirtableConversation(meta) {
      const tableURL = 'https://api.airtable.com/v0/app2N6x5jeRnIzSpL/Conversations';
      const headers  = {
        Authorization : 'Bearer patTeuxUuzgG0ZU8Q.2eb9ff7f31afe3e06f3c128c5b5b832bcc4e4e85bd58a5007a8368f218d28b83',
        'Content-Type': 'application/json'
      };
    
      /* 1️⃣ look for an existing row */
      const lookup   = await fetch(
        `${tableURL}?filterByFormula={Conversation-ID}="${meta.conversationID}"`,
        { headers }
      ).then(r => r.json());
    
      const recordId = lookup.records?.[0]?.id ?? null;
      const method   = recordId ? 'PATCH' : 'POST';
      const endpoint = recordId ? `${tableURL}/${recordId}` : tableURL;
    
      /* 2️⃣ build/merge fields */
      const fields = {
        'Conversation-ID'      : meta.conversationID,
        'Agent-ID'             : meta.agentID,
        'Client-Name'          : meta.userName,
        'Email'                : meta.email,
        'User-ID'              : meta.userId || '',         // may be empty first time
        'Design-Brief-Firm-ID' : meta['Design-Brief-Firm-ID'] || '',
        'Time-Stamp'           : meta.timeStamp,
        'Time-Last-Edited'     : new Date().toISOString()
      };
    
      /* 3️⃣ save it */
      const saved = await fetch(endpoint, {
        method, headers, body: JSON.stringify({ fields })
      }).then(r => r.json());
    
      window.airtableRecordId = saved.id;   // keep global for later PATCH
      console.log(`ensureAirtableConversation - ${method} OK, id:`, saved.id);
      return saved.id;
    }
    window.ensureAirtableConversation = ensureAirtableConversation;


    // Function to fetch and log conversation messages
    async function fetchConversationMessages(conversationID) {
      if (!conversationID) {
        console.log("No conversationID provided.");
        return;
      }
    
      try {
        const response = await fetch(`${baseUrl}/knowledge/list`, {
          method: "POST",
          headers: {
            Authorization: authorizationToken,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            knowledge_set: conversationID,
            page_size: 999, // Adjust as needed
            sort: [{ insert_date_: "desc" }], // Newest message first
          }),
        });
    
        if (!response.ok) {
          console.error("Error fetching conversation:", await response.text());
          return;
        }
    
        const data = await response.json();
        const messages = data.results || [];
    
        console.log("Fetched conversation messages:", messages);
        return messages;
      } catch (error) {
        console.error("Error accessing Relevance API:", error);
      }
    }
    

    // Function to render conversation messages in the chat UI
    function renderConversationMessages(messages) {
      if (!Array.isArray(messages) || messages.length === 0) {
        console.log("No messages to render.");
        return;
      }
    
      // Reverse the order to render messages in chronological order
      messages.reverse();
    
      // Skip the first user message if it exists
      const filteredMessages = messages.filter((message, index) => {
        const role = message?.data?.message?.role;
        // Exclude the very first user message
        return !(index === 0 && role === "user");
      });
    
      filteredMessages.forEach((message) => {
        const role = message?.data?.message?.role;
        const content = message?.data?.message?.content;
      
        if (role && content) {
          const isUser = role === "user";
          // Render the message
          const chatBlock = createChatBlock(isUser, content);
      
          if (isUser && conversationUserAvatar) {
            const userAvatarElement = chatBlock.querySelector('.chat_user-avatar');
            if (userAvatarElement) {
              // Add the additional class to override the avatar style.
              userAvatarElement.classList.add("conversation-user-avatar");
            }
          }
        }
      });

    
      // Scroll to the bottom of the conversation
      conversationWrapper.scrollTop = conversationWrapper.scrollHeight;
    }
    
    if (conversationID) {
      // --- NEW: Fetch conversation metadata and render header ---
      fetchConversationMetadata(conversationID).then((metadata) => {
        if (metadata) {
          renderConversationHeader(metadata);
        }
      });
    
      console.log("Conversation ID found:", conversationID);
      // Fetch and render messages as before
      fetchConversationMessages(conversationID).then((messages) => {
        if (messages) {
          renderConversationMessages(messages);
          conversationId = conversationID; 
          console.log("Global conversationId set to:", conversationId);
        } else {
          console.error("Failed to fetch conversation messages.");
        }
        // Show the input wrapper after messages are loaded
        showChatInputWrapper(); // <-- NEW HELPER
        console.log("Input wrapper displayed.");
      });
    } else {
      console.log("No conversation ID found. Hiding input wrapper.");
      chatInputWrapper.style.display = "none";
    }


    let conversationId = null;      // local variable used in this file
    window.conversationId = null;   // copy on window for other scripts


    
    function adjustHeight() {
      const MAX_HEIGHT = 400; // Maximum height for the textarea in pixels
      
      // Reset the textarea height so we can recalculate the correct scrollHeight
      textarea.style.height = 'auto';
      
      // Get the new height based on the current content
      const newHeight = textarea.scrollHeight;
      
      // Apply the maximum height limit and enable internal scrolling if necessary
      if (newHeight > MAX_HEIGHT) {
        textarea.style.height = MAX_HEIGHT + "px";
        textarea.style.overflowY = "auto"; // Allow vertical scroll within the textarea
      } else {
        textarea.style.height = newHeight + "px";
        textarea.style.overflowY = "hidden"; // Hide the scrollbar when not needed
      }
      
      // Calculate how many pixels the textarea has expanded beyond its base height
      const currentHeight = parseInt(textarea.style.height, 10);
      const extraHeight = Math.max(0, currentHeight - BASE_TEXTAREA_HEIGHT);
      
      // Update the spacer's height so that the conversation messages are pushed upward accordingly
      chatSpacer.style.height = extraHeight + "px";
    }



    function resetHeight() {
      textarea.value = "";
      // Reset the textarea to its base height
      textarea.style.height = BASE_TEXTAREA_HEIGHT + "px";
      textarea.style.overflowY = "hidden"; // Ensure the scrollbar is hidden initially
      // Reset the spacer height to 0 so it no longer pushes the conversation upward
      chatSpacer.style.height = "0px";
    }


  
    
    function createChatBlock(isUser, content) {
      // Preprocess content to remove bullet points before { ... }
      content = content.replace(/(^|\n)[\s]*[-*]\s*(?=\{)/g, '$1');
      const segments = [];
      const regex = /(\{[\s\S]*?\})/g;
      let lastIndex = 0;
      let match;
    
      while ((match = regex.exec(content)) !== null) {
        if (match.index > lastIndex) {
          const textSegment = content.substring(lastIndex, match.index);
          segments.push({ type: "text", content: textSegment });
        }
        segments.push({ type: "option", content: match[1] });
        lastIndex = regex.lastIndex;
      }
    
      if (lastIndex < content.length) {
        const textSegment = content.substring(lastIndex);
        segments.push({ type: "text", content: textSegment });
      }
    
      let optionGroup = [];
      let lastOptionIndex = -1;
      let hasRenderedBotAvatar = false;
    
      // Track both the first and last created blocks for scrolling
      let firstCreatedBlock = null;
      let lastCreatedBlock = null;
    
      segments.forEach((segment, index) => {
        if (segment.type === "text") {
          const textContent = segment.content.trim();
          if (textContent) {
            // If there are pending options, render them before this text
            if (optionGroup.length > 0) {
              const isOptionsAtEnd = !hasNonEmptyTextAfterIndex(segments, lastOptionIndex);
              renderOptions(optionGroup, isOptionsAtEnd);  // <-- FIXED: call renderOptions here
              optionGroup = [];
            }
    
            const hideAvatar = !isUser && hasRenderedBotAvatar;
            const newlyRenderedBlock = renderTextSegment(textContent, isUser, hideAvatar);
    
            // Keep track of the first and last blocks for scrolling behavior
            if (!firstCreatedBlock) {
              firstCreatedBlock = newlyRenderedBlock;
            }
            lastCreatedBlock = newlyRenderedBlock;
    
            hasRenderedBotAvatar = true;
          }
        } else if (segment.type === "option") {
          optionGroup.push(segment.content.slice(1, -1).trim());
          lastOptionIndex = index;
        }
      });
    
      // If there are options remaining after the loop, render them
      if (optionGroup.length > 0) {
        const isOptionsAtEnd = !hasNonEmptyTextAfterIndex(segments, lastOptionIndex);
        const newlyRenderedBlock = renderOptions(optionGroup, isOptionsAtEnd);
        if (newlyRenderedBlock) {
          if (!firstCreatedBlock) {
            firstCreatedBlock = newlyRenderedBlock;
          }
          lastCreatedBlock = newlyRenderedBlock;
        }
        optionGroup = [];
      }
    
      // Scroll the conversation wrapper to the bottom
      conversationWrapper.scrollTop = conversationWrapper.scrollHeight;
    
      // Attach a pointer on the last block to reference the first block
      if (lastCreatedBlock) {
        lastCreatedBlock.__myFirstBlock = firstCreatedBlock;
      }
    
      // Re-append the spacer element so it is always the very last child
      conversationWrapper.appendChild(chatSpacer);
    
      // Return the last block as before
      return lastCreatedBlock;
    }



    
    // Helper function to check if there's non-empty text after a given index
    function hasNonEmptyTextAfterIndex(segments, currentIndex) {
      for (let i = currentIndex + 1; i < segments.length; i++) {
        if (segments[i].type === "text" && segments[i].content.trim()) {
          return true;
        }
      }
      return false;
    }
    
    function renderTextSegment(text, isUser, hideAvatar) {
      if (!text) return;
    
      // 1) (Optional) Convert user line breaks to Markdown line breaks
      if (isUser) {
        text = text.replace(/\n/g, '  \n');
      }
    
      // 2) Create the outer chat block elements
      const chatBlockWrapper = document.createElement('div');
      chatBlockWrapper.className = 'chat_block-wrapper';
    
      const chatBlock = document.createElement('div');
      chatBlock.className = 'chat_block';
    
      const botAvatar = document.createElement('div');
      botAvatar.className = 'chat_bot-avatar';
      if (isUser || hideAvatar) botAvatar.classList.add('opacity-0');
    
      const userAvatar = document.createElement('div');
      userAvatar.className = 'chat_user-avatar';
      if (!isUser) userAvatar.classList.add('opacity-0');
    
      const chatInnerWrapper = document.createElement('div');
      chatInnerWrapper.className = `chat_inner-wrapper ${isUser ? 'user-message' : ''}`;
    
      // 3) Parse the text as Markdown, sanitize it
      const parsedHtml = marked.parse(text);
      const sanitizedHtml = DOMPurify.sanitize(parsedHtml);
    
      // 4) Insert the sanitized HTML into the DOM
      chatInnerWrapper.innerHTML = sanitizedHtml;
    
      // 5) **Call replacePreCodeWithMarkdown**: 
      //    This function will look for any <pre><code> blocks 
      //    in 'chatInnerWrapper' and replace them with a normal <div> 
      //    plus a "Copy" button that copies plain text.
      replacePreCodeWithMarkdown(chatInnerWrapper);
    
      // 6) Append these elements to form the final chat message
      chatBlock.appendChild(botAvatar);
      chatBlock.appendChild(chatInnerWrapper);
      chatBlock.appendChild(userAvatar);
      chatBlockWrapper.appendChild(chatBlock);
      conversationWrapper.appendChild(chatBlockWrapper);
    
      // 7) Scroll to the bottom of the chat
      conversationWrapper.scrollTop = conversationWrapper.scrollHeight;
      return chatBlockWrapper;

    }


    function renderOptions(options, isEnd) {
      if (options.length === 0) return;
    
      // Create a container for the multi-choice block
      const chatBlockWrapper = document.createElement("div");
      chatBlockWrapper.className = "chat_block-wrapper is-multi-choice-options";
      if (isEnd) {
        chatBlockWrapper.classList.add("is-end");
      }
    
      const chatBlock = document.createElement("div");
      chatBlock.className = "chat_block is-multi-choice-options";
    
      options.forEach((optionText) => {
        // Create a container for the option buttons and set it as a flex container
        const optionContainer = document.createElement("div");
        optionContainer.className = "chat_multi-choice-container";
        optionContainer.style.display = "flex";
        optionContainer.style.alignItems = "center";
        optionContainer.style.justifyContent = "flex-start";
    
        // Create the main clickable option button (Left side)
        const optionDiv = document.createElement("div");
        optionDiv.className = "chat_multi-choice-option";
        optionDiv.style.width = "60%";
        const optionHeading = document.createElement("span");
        optionHeading.className = "chat-button-text";
        optionHeading.style.fontWeight = "bold";
        optionHeading.textContent = optionText;
        optionDiv.appendChild(optionHeading);
    
        // Event listener for the main button: append text to textarea and mark as chosen
        optionDiv.addEventListener("click", () => {
          const userInput = document.getElementById("chat-user-input");
          userInput.value += `${optionText}\n`;
          adjustHeight();
          optionDiv.classList.add("is-chosen");
        });
    
        // Create the send button (Right side)
        const sendBtn = document.createElement("div");
        sendBtn.className = "chat_multi-choice-send";
        sendBtn.style.width = "47px";
        sendBtn.style.height = "100%";
        sendBtn.style.display = "flex";
        sendBtn.style.alignItems = "center";
        sendBtn.style.justifyContent = "center";
    
        // Set inner HTML with the provided SVG icon
        sendBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--heroicons" width="100%" height="100%" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24">
          <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M6 12L3.269 3.125A59.8 59.8 0 0 1 21.486 12a59.8 59.8 0 0 1-18.217 8.875zm0 0h7.5"></path>
        </svg>`;
    
        // STEP 4: Replace the multi-choice sendBtn logic:
        
        sendBtn.addEventListener("click", (event) => {
          event.stopPropagation(); // Prevent the left button's event from firing
          sendBtn.classList.add("is-chosen"); // Add the 'is-chosen' combo class
        
          // Stop STT if it's on
          if (isMicOn) {
            stopDeepgramTranscription();
            isMicOn = false;
            const micBtn = document.getElementById("chat-user-input-mic");
            if (micBtn) micBtn.classList.remove("is-active");
            console.log("Stopped mic via multi-choice send.");
          }
        
          // Stop TTS (optional)
          stopCurrentVoiceOutput();
        
          // Render the option as a user message
          createChatBlock(true, optionText);
        
          // Reset transcripts so we start fresh next time
          finalTranscript = "";
          lastInterim = "";
        
          // Clear the text input area (like the main send button)
          setTimeout(() => {
            resetHeight();
          }, 0);
        
          // Immediately send the option as a message to the AI
          (async () => {
            const { chatInnerWrapper, chatBlockWrapper } = createLoadingBlock();
            try {
              const agentResponse = await startConversation(optionText);
              conversationWrapper.removeChild(chatBlockWrapper);
              createChatBlock(false, agentResponse);
            } catch (error) {
              conversationWrapper.removeChild(chatBlockWrapper);
              createChatBlock(false, "Sorry, something went wrong.");
            }
          })();
        });



    
        // Append both buttons to the container
        optionContainer.appendChild(optionDiv);
        optionContainer.appendChild(sendBtn);
        // Append the container to the chat block
        chatBlock.appendChild(optionContainer);
      });
    
      // Append the chat block to the wrapper and add it to the conversation container
      chatBlockWrapper.appendChild(chatBlock);
      conversationWrapper.appendChild(chatBlockWrapper);
    }

    
    // Function to clean option text
    function cleanOptionText(text) {
      // Only remove bullet points '-' or '*'
      text = text.replace(/^[\s]*[-*]\s*/, "");
      text = text.replace(/[*#_`~>]/g, ""); // Retain dashes, remove other unwanted symbols
      text = text.replace(/\s+/g, " ").trim(); // Normalizes whitespace
      return text;
    }

    
    // Function to start a conversation with the AI
    async function startConversation(message) {
      try {
        const requestBody = {
          message: { role: "user", content: message },
          agent_id: agentId,
          ...(conversationId && { conversation_id: conversationId }) // Include conversationId if it exists
        };
    
        const response = await fetch(`${baseUrl}/agents/trigger`, {
          method: "POST",
          headers: headers,
          body: JSON.stringify(requestBody),
        });
    
        if (response.ok) {
          const data = await response.json();
    
          // Set conversationId only if it's a new conversation
          if (!conversationId) {
            conversationId = data.conversation_id;
            window.conversationId = conversationId;
            console.log(`New conversation started with ID: ${conversationId}`);
          }
    
          const { studio_id, job_id } = data.job_info;
          const agentResponse = await pollAgentResponse(studio_id, job_id);
          return agentResponse;
        } else {
          const errorData = await response.json();
          console.error("Error starting conversation:", errorData);
          return `Sorry, something went wrong: ${errorData.message || response.statusText}`;
        }
      } catch (error) {
        console.error("Error starting conversation:", error);
        return "Sorry, something went wrong.";
      }
    }


    
    // Function to poll the AI for a response
    async function pollAgentResponse(studio_id, job_id) {
      const pollUrl = `${baseUrl}/studios/${studio_id}/async_poll/${job_id}`;
      let done = false;
    
      while (!done) {
        try {
          const response = await fetch(pollUrl, { method: "GET", headers: headers });
          if (response.ok) {
            const data = await response.json();
            for (const update of data.updates) {
              if (update.type === "chain-success" && update.output.status === "complete") {
                done = true;
                return update.output.output.answer;
              }
            }
          } else {
            console.error("Error during polling:", response.statusText);
            return "Sorry, something went wrong while waiting for the response.";
          }
        } catch (error) {
          console.error("Error during polling:", error);
          return "Sorry, something went wrong while waiting for the response.";
        }
        await new Promise((resolve) => setTimeout(resolve, 1000));
      }
    }

    function createLoadingBlock() {
      const chatBlockWrapper = document.createElement("div");
      chatBlockWrapper.className = "chat_block-wrapper";
    
      const chatBlock = document.createElement("div");
      chatBlock.className = "chat_block";
    
      const botAvatar = document.createElement("div");
      botAvatar.className = "chat_bot-avatar";
    
      const chatInnerWrapper = document.createElement("div");
      chatInnerWrapper.className = "chat_inner-wrapper";
    
      // Create the loading animation container
      const loadAnimationContainer = document.createElement("div");
      loadAnimationContainer.className = "load-animation";
    
      // Use a GIF for loading
      const gifImage = document.createElement("img");
      gifImage.src =
        "https://cdn.prod.website-files.com/64e508e8bea103fa08b8f130/6761f50a16ce8196496d4724_load-animation.gif";
      gifImage.alt = "Loading...";
      loadAnimationContainer.appendChild(gifImage);
    
      chatInnerWrapper.appendChild(loadAnimationContainer);
      chatBlock.appendChild(botAvatar);
      chatBlock.appendChild(chatInnerWrapper);
      chatBlockWrapper.appendChild(chatBlock);
      conversationWrapper.appendChild(chatBlockWrapper);
    
      // 1) Scroll the chat container itself to the bottom
      conversationWrapper.scrollTop = conversationWrapper.scrollHeight;
    
      // 2) ALSO scroll the entire window to the bottom (like for AI/user messages)
      setTimeout(() => {
        window.scrollTo({
          top: document.body.scrollHeight,
          left: 0,
          behavior: "smooth", // Or "auto" if you want an instant jump
        });
      }, 50);
    
      return { chatInnerWrapper, chatBlockWrapper };
    }


    // STEP 3A: Replace your entire handleSubmit() with this:

    async function handleSubmit() {
      // 1) If the AI is already processing, do nothing
      if (isBusy) return;
    
      // 2) Mark the system as busy
      isBusy = true;
    
      // 3) Stop STT (Deepgram) if the mic is on
      if (isMicOn) {
        stopDeepgramTranscription();
        isMicOn = false;
        const micBtn = document.getElementById("chat-user-input-mic");
        if (micBtn) micBtn.classList.remove("is-active");
        console.log("Stopped mic on submit.");
      }
    
      // 4) Stop TTS if it’s currently playing (optional, if you want the old code approach)
      stopCurrentVoiceOutput();
    
      // 5) Disable the user input fields (visual feedback)
      textarea.disabled = true;
      userSubmit.disabled = true;
    
      // 6) Grab the user's message
      const message = textarea.value.trim();
      if (!message) {
        // If empty, unlock so user can try again
        isBusy = false;
        textarea.disabled = false;
        userSubmit.disabled = false;
        return;
      }
    
      // 7) Render user’s message immediately
      createChatBlock(true, message);
    
      // (New) Reset transcripts so we start fresh next time
      finalTranscript = "";
      lastInterim = "";
    
      // 8) Reset the textarea
      resetHeight(); // Clears + resets textarea
    
      // 9) Show the loading block
      const { chatInnerWrapper, chatBlockWrapper } = createLoadingBlock();
    
      try {
        // 10) Send to AI + wait for response
        const agentResponse = await startConversation(message);
    
        // 11) Remove loading block + show AI response
        conversationWrapper.removeChild(chatBlockWrapper);
        createChatBlock(false, agentResponse);
      } catch (error) {
        console.error("Error while waiting for AI response:", error);
        conversationWrapper.removeChild(chatBlockWrapper);
        createChatBlock(false, "Sorry, something went wrong.");
      } finally {
        // 12) Unlock so user can send next message
        isBusy = false;
        textarea.disabled = false;
        userSubmit.disabled = false;
      }
    }



    
    // Attach event listeners
    textarea.addEventListener("input", adjustHeight);
    userSubmit.addEventListener("click", handleSubmit);
    
    textarea.addEventListener("keydown", (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key === "Enter") {
        e.preventDefault();
        handleSubmit();
      }
    });
    
  
    
    // -----------------------------
    // Automatically Start Conversation
    // -----------------------------
    async function startInitialConversation() {
      // Clear existing chat blocks
      while (conversationWrapper.firstChild) {
        conversationWrapper.removeChild(conversationWrapper.firstChild);
      }
      console.log("Cleared existing chat blocks.");
    
      // Remove conversationID from the URL
      const url = new URL(window.location.href);
      url.searchParams.delete('conversationID');
      window.history.replaceState({}, '', url);
      console.log("Removed conversationID from URL.");
    
      // Reset the global conversationId variable
      conversationId = null;
      console.log("Reset conversationId to null.");
    
      // Create loading block
      const { chatInnerWrapper, chatBlockWrapper } = createLoadingBlock();
    
      // Construct the initial message
      const currentTime = new Date().toLocaleString();
      let initialMessage = `conversation_name=${currentTime}, current_username=${name}, current_user_email=${email}`;
      if (agentInfo) {
        initialMessage += `, additional_info=${agentInfo}`;
      }
      console.log("Sending initial message to AI:", initialMessage);
    
      // Send initial message to AI (not shown as user's message)
      const agentResponse = await startConversation(initialMessage);
    
      // Remove loading block
      conversationWrapper.removeChild(chatBlockWrapper);
    
      // Display only the AI's response
      createChatBlock(false, agentResponse);
    
      // Show the input UI so the user can continue
      if (chatInputWrapper) {
        showChatInputWrapper(); // <-- CALL THE HELPER
        console.log("Input wrapper displayed (grid or flex).");
      }
    }


    const startConversationButton = document.getElementById('start-new-conversation');
    if (startConversationButton) {
      startConversationButton.addEventListener('click', async (event) => {
        event.preventDefault();
        console.log('Starting a new conversation...');
    
        // Start a new conversation
        await startInitialConversation(); // Existing function to start the conversation
    
        // Collect metadata for new conversation
        const container = document.getElementById('ai-agent-container');
        const userName = container.getAttribute('data-user-name') || 'Guest';
        
        // Render header for new conversation (Summary not available)
        renderConversationHeader({
          clientName: userName,
          timeLastEdited: new Date().toLocaleString(),
          summary: null // No summary yet for a new conversation
        });
    
        // Collect additional metadata for saving to Airtable
        const agentID = container.getAttribute('data-agent-id') || 'Unknown Agent';
        const timeStamp = new Date().toISOString(); // Current date/time in ISO format
        
        // Step 1: Extract the alternate user ID from the URL using the helper function
        const alternateUserId = getAlternateUserIdFromUrl();
        
        // Step 2: Determine what to save in the metadata object
        let finalUserId = userId;           // Default to the normal user ID
        let designBriefFirmId = "";         // Empty by default
        
        // If an alternate user ID is provided (via the query parameter)
        if (alternateUserId) {
          finalUserId = "";                 // Leave the userId property empty
          designBriefFirmId = alternateUserId; // Save the alternate firm ID for the new property
        }
        
        // Step 3: Build the metadata object accordingly
        const metadata = {
          userName,
          agentID,
          conversationID: conversationId || 'Unknown Conversation ID',
          timeStamp,
          userId: finalUserId,  // Will be empty if an alternate ID is present
          email,              // Include the user's email
        };
        
        // If a design brief firm ID exists, add it as a new property in the metadata
        if (designBriefFirmId) {
          metadata["Design-Brief-Firm-ID"] = designBriefFirmId;
        }

        await ensureAirtableConversation(metadata);

      });
    } else {
      console.error("Button with id 'start-new-conversation' not found.");
    }

    
    document.addEventListener("click", (event) => {
        const voiceToggle = event.target.closest("#chat-voice-toggle");
        if (!voiceToggle) return;
    
        // Toggle the voice state
        isVoiceOn = !isVoiceOn;
        voiceToggle.classList.toggle("is-active", isVoiceOn);
        console.log(`Voice Output is now ${isVoiceOn ? "ON" : "OFF"}`);
    
        // If voice output is turned off, stop the current audio immediately
        if (!isVoiceOn && currentAudio) {
            currentAudio.pause(); // Stop playback
            currentAudio = null;  // Release the audio instance
            console.log("Voice output stopped immediately as toggle is OFF.");
        }
    });


    let currentAudio = null; // Keep your existing global definition if you had it
    
    const playVoiceOutput = async (text) => {
      // Check if the voice output toggle is ON
      if (!isVoiceOn) return;
    
      // Your ElevenLabs API key
      const apiKey = "sk_065dc50b4b41b24e68999e7f5bbbd45e0dead586465ace18"; 
      // Your existing default voice ID (male voice)
      const defaultVoiceId = "IKne3meq5aSn9XLyUdCD";
      // Use agent-specific voice if available, otherwise fallback
      const voiceId = window.__agentVoiceId || defaultVoiceId;
    
      try {
        // Stop any currently playing audio
        if (currentAudio) {
          currentAudio.pause();
          currentAudio = null;
        }
    
        // Convert Markdown to plain text (you already have markdownToPlainText)
        const plainText = markdownToPlainText(text);
    
        // Request a streaming TTS response from ElevenLabs
        const response = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${voiceId}/stream`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "xi-api-key": apiKey,
          },
          body: JSON.stringify({
            text: plainText,
            model_id: "eleven_flash_v2_5",
          }),
        });
    
        if (!response.ok) throw new Error("Failed to fetch audio stream from ElevenLabs");
    
        // Stream the audio chunks
        const reader = response.body.getReader();
        const audioChunks = [];
        let done = false;
    
        while (!done) {
          // If the user toggles voice OFF mid-playback, stop immediately
          if (!isVoiceOn) {
            if (currentAudio) currentAudio.pause();
            currentAudio = null;
            return;
          }
    
          const { done: readerDone, value } = await reader.read();
          if (readerDone) {
            done = true;
            break;
          }
          audioChunks.push(value);
        }
    
        // Decode chunks into playable audio
        const audioData = new Blob(audioChunks);
        const arrayBuffer = await audioData.arrayBuffer();
        const audioContext = new AudioContext();
        await audioContext.decodeAudioData(arrayBuffer); // pre-decode
    
        // Create an HTML Audio element to play the blob
        const audio = new Audio();
        audio.src = URL.createObjectURL(audioData);
        currentAudio = audio; // Track globally
    
        // Play the audio
        audio.play();
        audio.onended = () => {
          // Release when finished
          currentAudio = null;
        };
      } catch (error) {
        console.error("Error during TTS playback:", error);
        currentAudio = null;
      }
    };


    const originalCreateChatBlock = createChatBlock;
    createChatBlock = function (isUser, content) {
      // 1) Render the message by calling the original function
      const newBlock = originalCreateChatBlock(isUser, content);
    
      // 2) If this is a USER message, we do the old "scroll to bottom"
      if (isUser) {
        setTimeout(() => {
          window.scrollTo({
            top: document.body.scrollHeight,
            left: 0,
            behavior: "smooth",
          });
        }, 50);
      } else {
        // 3) If this is an AI message:
        //    scroll so top of the FIRST sub-block is near the top of the screen
        setTimeout(() => {
          // newBlock.__myFirstBlock is assigned in the original function
          const firstBlock = newBlock.__myFirstBlock || newBlock;
    
          // Use getBoundingClientRect() to find the Y position
          const rect = firstBlock.getBoundingClientRect();
          const absoluteY = rect.top + window.scrollY;
          let scrollTarget = absoluteY - 80; // 80px offset from top
          if (scrollTarget < 0) scrollTarget = 0;
    
          window.scrollTo({
            top: scrollTarget,
            left: 0,
            behavior: "smooth",
          });
        }, 50);
    
        // Also keep TTS for AI messages
        playVoiceOutput(content);
      }
    
      // Return the block so existing code is unchanged
      return newBlock;
    };


    function initTooltips() {
      const tooltipEl = document.getElementById("global-tooltip");
      if (!tooltipEl) {
        console.warn("No #global-tooltip element found. Tooltips won't appear.");
        return;
      }
    
      let hoverTimer = null;
      let currentTarget = null;
    
      // Query all buttons with class .my-btn and data-tooltip
      const tooltipButtons = document.querySelectorAll(".my-btn[data-tooltip]");
      console.log("Tooltip: found", tooltipButtons.length, "buttons.");
    
      tooltipButtons.forEach((btn) => {
        btn.addEventListener("mouseenter", (e) => {
          currentTarget = e.currentTarget;
          const tooltipText = currentTarget.getAttribute("data-tooltip");
    
          // 1 second delay before showing the tooltip
          hoverTimer = setTimeout(() => {
            // Insert text
            tooltipEl.textContent = tooltipText;
    
            // Make it visible so we can measure its width/height
            tooltipEl.classList.remove("tooltip-hidden");
            tooltipEl.classList.add("tooltip-visible");
    
            // Calculate positions with getBoundingClientRect
            const rect = currentTarget.getBoundingClientRect();
    
            // Measure the tooltip once it's visible
            const tooltipWidth = tooltipEl.offsetWidth;
            const tooltipHeight = tooltipEl.offsetHeight;
    
            // Place it above the button: 
            // top = button's top coordinate - tooltip height - 10px gap
            const top = rect.top - tooltipHeight - 9;
    
            // Center horizontally over the button:
            // left = button's left + (button width / 2) - (half of tooltip width)
            const left = rect.left + (rect.width / 2) - (tooltipWidth / 2);
    
            // Because we're using position: fixed, 
            // these coordinates are relative to the viewport
            tooltipEl.style.top = `${top}px`;
            tooltipEl.style.left = `${left}px`;
          }, 1000); // <-- 1 second delay
        });
    
        btn.addEventListener("mouseleave", () => {
          clearTimeout(hoverTimer);
    
          // Hide tooltip if it was shown
          tooltipEl.classList.remove("tooltip-visible");
          tooltipEl.classList.add("tooltip-hidden");
          currentTarget = null;
        });
      });
    }
    
    // Finally, call initTooltips() once
    initTooltips();

    /*************  Canvas sidebar infrastructure  *************/
(function addCanvasInfrastructure () {

  /* 1 – Create the grey panel (runs only once) */
  function ensureCanvasPanel () {
    if (document.getElementById('working-canvas')) return;   // already injected

    const wrp  = document.querySelector('.wrp.cnt');  // outer wrapper
    const main = wrp?.querySelector('.bSeCont');      // main chat column
    if (!wrp || !main) {
      console.warn('[Canvas] .wrp.cnt or .bSeCont not found');
      return;
    }

    /* Build the panel */
    const canvas = document.createElement('div');
    canvas.id        = 'working-canvas';
    canvas.className = 'canvas-panel';                // for CSS
    canvas.innerHTML = `
      <div class="canvas-header">
        <div class="canvas-header-left">
          <button id="canvas-close-btn"
                  class="canvas-icon-btn"
                  aria-label="Close">×</button>
          <span class="canvas-title">The Canvas</span>
        </div>
    
        <div class="canvas-header-right">
          <button id="canvas-undo-btn"
                  class="canvas-icon-btn"
                  data-tooltip="Undo"
                  aria-label="Undo">
            <!-- Undo SVG -->
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                 xmlns="http://www.w3.org/2000/svg">
              <path d="M21 13.6647C21 14.9442 20.7333 16.0559 20.1996 17C19.666 17.9503 18.8997 18.6863 17.9008 19.208C16.908 19.736 15.7198 20 14.3361 20H12.0372..."
                    fill="currentColor"/>
            </svg>
          </button>
    
          <button id="canvas-redo-btn"
                  class="canvas-icon-btn"
                  data-tooltip="Redo"
                  aria-label="Redo">
            <!-- Redo SVG -->
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                 xmlns="http://www.w3.org/2000/svg">
              <path d="M3 13.6647C3 12.3976 3.26992 11.2826 3.80973 10.3199C4.35574..."
                    fill="currentColor"/>
            </svg>
          </button>
    
          <button id="canvas-copy-btn"
                  class="canvas-icon-btn"
                  data-tooltip="Copy"
                  aria-label="Copy">
            <!-- Copy SVG -->
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                 xmlns="http://www.w3.org/2000/svg">
              <path fill-rule="evenodd" clip-rule="evenodd"
                    d="M7 5C7 3.34315 8.34315 2 10 2H19..."
                    fill="currentColor"/>
            </svg>
          </button>
    
          <button id="canvas-send-btn"
                  class="canvas-icon-btn canvas-send-btn"
                  data-tooltip="Send via email"
                  aria-label="Send via email">
            <!-- Upload-square-arrow-up SVG (no interior fill) -->
            <svg width="24" height="24" viewBox="0 0 20 20" fill="none"
                 xmlns="http://www.w3.org/2000/svg">
              <path d="M6.667 6.667 10 3.333l3.333 3.334M10 3.75v8.75"
                    stroke="currentColor" stroke-width="1.5"
                    stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M3.333 11.667v.2c0 1.68 0 2.52.327 3.162.288.565.747
                       1.024 1.312 1.312.642.327 1.482.327 3.162.327h3.734
                       c1.68 0 2.52 0 3.162-.327.565-.288 1.024-.747
                       1.312-1.312.327-.642.327-1.482.327-3.162v-.2"
                    stroke="currentColor" stroke-width="1.5"
                    stroke-linecap="round"/>
            </svg>
          </button>
        </div>
      </div>
    
      <div class="canvas-body">
        <textarea id="canvas-editor"></textarea>
      </div>
    `;
    /* Insert immediately after the main content column */
    main.insertAdjacentElement('afterend', canvas);


    /*  ░░░  EasyMDE loader / initialiser  ░░░ */
    function initCanvasEditor(){
      if(window.__canvasMDE){ return; }
    
      const css = document.createElement('link');
      css.rel  = 'stylesheet';
      css.href = 'https://cdn.jsdelivr.net/npm/easymde/dist/easymde.min.css';
      document.head.appendChild(css);
    
      const js  = document.createElement('script');
      js.src    = 'https://cdn.jsdelivr.net/npm/easymde/dist/easymde.min.js';
      js.onload = () => {
        window.__canvasMDE = new EasyMDE({
          element: document.getElementById('canvas-editor'),
          spellChecker: false,
          status: false,
          autofocus: true,
          autoDownloadFontAwesome: false,
          toolbar: [
            'bold','italic','strikethrough','heading','|',
            'quote','unordered-list','ordered-list','code','horizontal-rule','|',
            'preview','side-by-side','fullscreen'
          ]
        });
      };
      document.head.appendChild(js);
    }
    
    initTooltips();      // (re-hook tool-tips for the new buttons, already in your code)
    initCanvasEditor();  // <-- add this call right here



    
    /* NEW — re-initialise tool-tips so the fresh buttons get listeners */
    if (typeof initTooltips === 'function') initTooltips();
  }

  /* 2 – Wire the open / close behaviour */
  function wireToggleBehaviour () {
    const toggleBtn = document.getElementById('chat-canvas-toggle');
    const wrp       = document.querySelector('.wrp.cnt');
    if (!toggleBtn || !wrp) return;

    const open  = () => { wrp.classList.add('canvas-open');  toggleBtn.classList.add('is-active'); };
    const close = () => { wrp.classList.remove('canvas-open'); toggleBtn.classList.remove('is-active'); };

    /* open ⇄ close when the toolbar button is clicked */
    toggleBtn.addEventListener('click', () => {
      wrp.classList.contains('canvas-open') ? close() : open();
    });

    /* close when the “×” inside the panel is clicked */
    wrp.addEventListener('click', (e) => {
      if (e.target.id === 'canvas-close-btn') close();
    });
  }

  /* Run immediately */
  ensureCanvasPanel();
  wireToggleBehaviour();

})();   /* ← end Canvas IIFE */
/***********  (keep existing code below this point)  ***********/


    // --- Begin link update functionality ---
    (function() {
      // Function to update all anchor tags within a given root element
      function updateLinks(root) {
        const links = root.querySelectorAll('a');
        links.forEach(link => {
          link.setAttribute('target', '_blank');
          link.setAttribute('rel', 'noopener noreferrer');
        });
      }
      
      // Check if the DOM is already loaded; if so, run updateLinks immediately.
      if (document.readyState === "loading") {
        document.addEventListener('DOMContentLoaded', function() {
          updateLinks(document);
        });
      } else {
        updateLinks(document);
      }
      
      // Set up a MutationObserver to catch any dynamically added links later.
      const observer = new MutationObserver(function(mutations) {
        mutations.forEach(mutation => {
          mutation.addedNodes.forEach(node => {
            // Only process element nodes.
            if (node.nodeType === Node.ELEMENT_NODE) {
              // If the node itself is a link, update it.
              if (node.tagName.toLowerCase() === 'a') {
                node.setAttribute('target', '_blank');
                node.setAttribute('rel', 'noopener noreferrer');
              }
              // Update any links contained within the node.
              updateLinks(node);
            }
          });
        });
      });
      
      // Start observing the entire document body for changes.
      observer.observe(document.body, { childList: true, subtree: true });
    })();
     // --- End link update functionality ---




  })();
</script>
